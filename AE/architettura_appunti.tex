\documentclass[10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{multicol}
\usepackage[a4paper, total={18cm, 25cm}]{geometry}
\begin{document}
\title{Architettura degli Elaboratori}
\author{Federico Matteoni}
\date{ }
\renewcommand*\contentsname{Indice}

\maketitle
\tableofcontents
\pagebreak
\section{Introduzione}
Appunti del corso di \textbf{Architettura degli Elaboratori} presi a lezione da \textbf{Federico Matteoni}.\\\\
Prof.: \textbf{Maurizio Bonuccelli}, maurizio.angelo.bonuccelli@unipi.it\\
\begin{list}{-}{Riferimenti web:}
\item \emph{http://pages.di.unipi.it/bonuccelli/aeb.html}
\item \emph{didawiki.cli.di.unipi.it/doku.php/informatica/ae/start}
\end{list}
Ricevimento: Martedì 10-12, stanza 294 DE\\
Esame: \textbf{scritto} (\textit{closed book}) e \textbf{orale}. I compitini sono validi solo per la sessione invernale (gen-feb)\\
\begin{list}{-}{Libri}
\item  M. Vanneschi \textit{Architettura degli Elaboratori}, Pisa University Press
\item D. A. Patterson \textit{Computer Organization \& Design - The Hardware/Software Interface}
\end{list}
\section{Cosa riguarda il corso}
Consiste in come sono fatti pc internamento da un punto di vista di sottosistemi senza scendere nei dettagli elettrici.
\begin{list}{-}{Il corso è diviso in quattro parti:}
\item Fondamenti e strutturazione firmware (I Compitino)
\item Macchina assembler (D-RISC) e processi
\item Architetture General-Purpose
\item Architetture parallele (II Compitino)
\end{list}
\section{Struttura a livelli}
Quando voglio costruire qualcosa di complesso lo faccio a pezzi, partendo da comp elementari messe insieme o studiate ad altro livello, messe ulteriorimente insieme ecc.\\
Ogni livello lo chiameremo \textbf{macchina virtuale} o MV, seguito da un numero che indica il numero di livello.\\
\begin{list}{-}{Due approcci fondamentali:}
\item \textbf{Linguistico}: stabilisce i livelli in base ai linguaggi usati
\item \textbf{Funzionale}: stabilisce i livelli in base a cosa fanno
\end{list}
\subsection{Macchine Virtuali}
[disegno]\\
MV$_{i}$ realizza politica P$_{i}$ con linguaggio L$_{i}$ e risorse R$_{i}$.\\Utilizza le funzionalità che il livello MV$_{i-1}$ (primitive) fornisce attraverso l'interfaccia\\\\
\textbf{Supporto a tempo di esecuzione} o \textbf{Runtime Support}: insieme dei livelli sottostanti. Nell'esempio, MVi ha come runtime support i livelli MVi-1 ... MV0.
Una macchina virtuale è modulare perché devo poterla modificare, deve essere portabile (riutilizzabile in più contesti possibili).
\begin{list}{}{}
\item \textbf{MV$_{4}$} Applicazioni\\L$_{4}$: Java, C\\R$_{4}$: costrutti
\item \textit{Interfaccia}: chiamate di sistema
\item \textbf{MV$_{3}$} Sistema Operativo\\L$_{3}$: C\\R$_{3}$: variabili condivise, risorse condivise
\item \textit{Interfaccia}: istruzioni assembler
\item \textbf{MV$_{2}$} Macchina assembler\\L$_{2}$: assembler (D-RISC)\\R$_{2}$: registri, memoria, canali di comunicazione
\item \textit{Interfaccia}: istruzioni firmware per l'assembler
\item \textbf{MV$_{1}$} Firmware\\L$_{1}$: microlinguaggio\\R$_{1}$: sommatore, commutatore
\item \textit{Interfaccia}: hardware
\item \textbf{MV$_{0}$} Hardware\\L$_{0}$: \textit{funzionamento dei circuiti elettronici}\\R$_{0}$: circuiti elettronici elemntari (AND, OR, NOT) 
\end{list}
Il corso riguarderà principalmente i livelli MV$_{2}$ $\rightarrow$ MV$_{0}$ incluse, comprese le istruzioni assembler.\\
Il livello firmware sarà fatto da \textbf{memoria}, \textbf{processore} e \textbf{dispositivi I/O}. I/O comunica bilaterale con memoria e Processore comunica bilaterale con memoria. Opzionalmente I/O comunica bilaterale direttamente con processore. Questa è l'architettura standard in maniera estremamente semplicistica.
Vedremo processore e memoria, non i dispositivi I/O perché troppo complessi.

\subsection{Compilazione vs Interpretazione}
\begin{multicols}{2}
\textbf{Compilatore}: è \textbf{statico}, vedendo tutto il codice può ottimizzarlo. Sostanzialmente è l'opera di un traduttore, che può leggersi il testo più volte per tradurlo alla perfezione.\\
\columnbreak

\textbf{Interprete}: è \textbf{dinamico}, quindi non può ottimizzare. Il firmware riceve un'istruzione alla volta quindi la interpreta.\\\\
\end{multicols}
Entrambe servono per tradurre il \textbf{codice sorgente} nel \textbf{programma oggetto} o \textbf{eseguibile}.\\

\textbf{Suppongo programmi}:\\
\begin{multicols}{2}
\texttt{for i=0; i++; i<n\\    A[i] = A[i] + B[i];}

\columnbreak
\texttt{for i=0; i++; i<n\\    B[i] = B[i] + C;}
\end{multicols}
Ricevendo i due blocchi di istruzioni, il compilatore riconosce che sono diverse e le compila in modo diverso. Però in entrambi i casi sono del tipo \textit{oggetto = somma due oggetti}, quindi produce una sequenza di istruzioni analoga (a meno di registri e dati, ovviamente).\\\\
Parte del secondo pezzo di codice, ad esempio, verrà tradotto in questa maniera:
\begin{multicols}{2}
\begin{list}{}{}
\item \texttt{LOAD R$_{base}$, R$_{I}$, R$_{1}$}
\item \texttt{ADD R$_{1}$, R$_{2}$, R$_{1}$}
\item \texttt{STORE R$_{base}$, R$_{I}$, R$_{1}$}
\item \texttt{INC R$_{I}$}
\item \texttt{IF$<$ R$_{I}$, R$_{N}$, LOOP}
\end{list}
\columnbreak
\begin{list}{}{}
\item \texttt{M[R[base] + R[I]] $\rightarrow$ R[1]}
\item \texttt{R[1] + R[2] $\rightarrow$ R[1]}
\item \texttt{R[1]  $\rightarrow$ M[R[base] + R[I]]}
\item \texttt{R[I] + 1 $\rightarrow$ R[I]}
\end{list}
Microlinguaggio corrispondente
\end{multicols}
\pagebreak
\section{Assembler D-RISC}
Istruzioni lunghe 32bit, primi 8bit per identificativo istruzione. Poi tre blocchi di 6Bit (R$_{i}$, R$_{j}$, R$_{h}$, in ogni blocco vi è mem semplicemente l'indice i, j o h). Poi 6 bit tipicamente inutilizzati (per estensioni future, istruzioni particolare e per riempire le locaz. di mem che sono tutte a 32 bit).\\
2$^{6}$ = 64 registri generali nel processore\\
Ad esempio \texttt{ADD R$_{i}$, R$_{j}$, R$_{h}$} significa \texttt{M[R[i] + R[j]] $\rightarrow$ R[h]}, e \texttt{ADD} è memorizzato con un determinato codice identificativo.\\
Per l'inizializzazione, ho il registro \texttt{R$_{0}$} che contiene sempre 0.

\paragraph{Esempio di RTS} \texttt{MV3 C = A + B}\\
Su MV$_{2}$ diventa \texttt{ADD R$_{A}$, R$_{B}$, R$_{C}$}\\
Su MV$_{1}$ ho registro A, registro B verso addizionatore/sottrattore (con alfa che indica operazione) e porta in C (con beta che indica scrittura attiva o meno)\\
Su MV$_{0}$ i vari componenti sono costruiti da una serie di gate (\texttt{AND}, \texttt{OR}, \texttt{NOT}).\\
\\
PO Parte Operativa\\
PC Parte Controllo\\
\texttt{roba eventuale}
\section{Reti Combinatorie}
In una rete combinatoria si ha una serie di segnali in input (X$_{1}$ ... X$_{n}$) che vengono trasformati in una serie di segnali in output (Y$_{1}$ ... Y$_{m}$). A seconda delle varie componenti presenti sulla rete combinatoria, un insieme di segnali 0/1 viene trasformato in un altro insieme di segnali 0/1 seguendo le regole dell'\textbf{algebra booleana}.\\
Elettricamente, quando un segnale vale 1 significa che la tensione è circa 5V.
\subsection{Algebra Booleana}
L'algebra booleana è computata su \textbf{due valori} e \textbf{tre operatori}:
\begin{center}
\begin{multicols}{2}
\texttt{false}\\\texttt{true}\\
\columnbreak
\texttt{AND}\\\texttt{OR}\\\texttt{NOT}
\end{multicols}
\end{center}
Esistono anche altri operatori, derivati dai tre precedenti: \texttt{XOR}, \texttt{NAND}, \texttt{NOR} ecc..
\paragraph{Proprietà} Vale la proprietà distributiva anche per la somma rispetto alla moltiplicazione, oltre il viceversa, quindi: \texttt{A(B+C) = AB + AC}, ma anche \texttt{A + BC = (A + B)(A + C)}.\\
\begin{list}{-}{Inoltre si hanno le cosiddette \textbf{proprietà di DeMorgan}:}
\item \texttt{$\overline{A + B}$ = $\overline{A}$ * $\overline{B}$}
\item \texttt{$\overline{AB}$ = $\overline{A}$ + $\overline{B}$}
\end{list}
\begin{multicols}{3}
\subsubsection{AND}
Anche detta \textbf{moltiplicazione logica}.\\
\begin{tabular}{cc|c}
X & Y & Z \\
0 & 0 & 0 \\
0 & 1 & 0 \\
1 & 0 & 0 \\
1 & 1 & 1 \\
\end{tabular}
\columnbreak
\subsubsection{OR}
Anche detta \textbf{somma logica}.\\
\begin{tabular}{cc|c}
X & Y & Z \\
0 & 0 & 0 \\
0 & 1 & 1 \\
1 & 0 & 1 \\
1 & 1 & 1 \\
\end{tabular}
\columnbreak
\subsubsection{NOT}
Anche detta \textbf{negazione logica}.\\
\begin{tabular}{c|c}
Y & Z \\
0 & 1 \\
1 & 0 \\
\end{tabular}
\end{multicols}
\pagebreak
Per costruire una \textbf{rete combinatoria} esistono varie tecniche. Quella che useremo si chiama \textbf{somma di prodotti}.
\subsection{Tecnica della Somma di Prodotti, o codifica degli 1}
\paragraph{La tecnica nel dettaglio} Partendo dalla \textbf{tabella di verità}, identifico le uscite che valgono 1. Di quelle uscite, \textbf{moltiplico (\texttt{AND})} tra loro le entrate \textbf{sulla stessa riga}, \textbf{nego le entrate che valgono 0} e \textbf{sommo (\texttt{OR}) tra loro le diverse righe}.
\paragraph{Un esempio con la somma algebrica} Partendo dalla seguente tabella di verità.\\
\begin{multicols}{2}
\begin{tabular}{cc|c|c}
X & Y & Z & R \\
0 & 0 & 0 & 0 \\
0 & 1 & 1 & 0 \\
1 & 0 & 1 & 0 \\
1 & 1 & 0 & 1\\
\end{tabular}
\columnbreak
\\Sfruttando la tecnica descritta sopra ottengo le seguenti espressioni per le due uscite:
\begin{list}{}{}
\item \texttt{Z = $\overline{X}$ * Y + X * $\overline{Y}$}
\item \texttt{R = X * Y}
\end{list}
\end{multicols}
Alternativamente, posso anche realizzare la \textbf{funzione complementare}, ovver fare il solito procedimento ma per le uscite che valgono 0 per poi negarle.\\
\begin{multicols}{2}
\begin{tabular}{cc|c|c}
X & Y & $\overline{Z}$ & R \\
0 & 0 & 1 & 0 \\
0 & 1 & 0 & 0 \\
1 & 0 & 0 & 0 \\
1 & 1 & 1 & 1\\
\end{tabular}
\columnbreak
\begin{list}{}{}
\item \texttt{Z = $\overline{\overline{X} * \overline{Y} + X * Y}$}
\item \texttt{R = X * Y}
\end{list}
\end{multicols}

\section{26-09-2019}
\begin{tabular}{cccc|c}
S1 & S2 & X & Y & S1* \\
0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 1 & 0\\
0 & 0 & 1 & 0 & 0\\
0 & 0 & 1 & 1 & 1\\
0 & 1 & 0 & 0 & 0\\
0 & 1 & 0 & 1 & 0\\
0 & 1 & 1 & 0 & 0\\
0 & 1 & 1 & 1 & 1\\
1 & 0 & 0 & 0 & 0\\
1 & 0 & 0 & 1 & 1\\
1 & 0 & 1 & 0 & 1\\
1 & 0 & 1 & 1 & 1\\
1 & 1 & 0 & 0 & 0\\
1 & 1 & 0 & 1 & 1\\
1 & 1 & 1 & 0 & 1\\
1 & 1 & 1 & 1 & 1\\
\end{tabular}
s1\' = ns1*ns2*x*y + ns1*s2*x*y + s1*ns2*nx*ny + s1*ns2*x*ny + s1*ns2*x*y + s1*s2*nx*y + s1*s2*x*ny + s1*s2*x*y\\
mappa di carnaut\\
00 01 11 10, così che tra due colonne cambi un solo bit\\
prendere multipli di due "uni", cioè 2/4/8... uni\\
Gli estremi sono logicamente collegati (colonna 00 e colonna 10 sono adiacenti quindi posso formare rettangoli anche tra loro)
\section{moduli operativi/unità funzionali}
Parte operativa: produce l'output\\
Parte controllo: dice alla PO \textit{come controllare} i suoi componenti (es. produe gli alfa (dicono cosa fare ai componenti) e i beta (quali registri in scrittura e quali no)). La PO porta alla PC le \textbf{variabili di condizionamento}, che istruiscono la PC su \textit{come} produrre alfa e beta.\\
PO e PC sono reti sequenziali.\\
In generale le mealy sono migliori: mediamente costano non di più e sono non più lente.\\
in mealy x va anche in omega.\\\\
1. PO --var condiz--> PC\\2. PC --alfa, beta-->PO\\3. PO --output Z--> \textit{fuori}\\
PO la faccio M-\\
PC la faccio M-\\
PO moore (ma non sarà automa), PC mealy\\\\
Funzionalmente Mealy e Moore sono \textbf{equivalenti}. Moore rispodne dopo un clock, mealy risponde subito.\\
var condiz: info che PO passa alla PC affincché P generi alfa e beta.\\\\
microlinguaggio uao\\
\section{La Memoria}
\end{document}