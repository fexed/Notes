\documentclass[10pt]{book}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{multicol}
\usepackage[bookmarks]{hyperref}
\usepackage[a4paper, total={18cm, 25cm}]{geometry}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{makecell}
\usepackage{mathrsfs}
\graphicspath{ {./img/} }
\usepackage{color}

\begin{document}
\renewcommand*\contentsname{Indice}
\title{Elementi di Calcolo e Complessità}
\author{Federico Matteoni}
\date{A.A. 2019/20}
\maketitle
\tableofcontents
\pagebreak
\section*{Introduzione}
Prof. Pierpaolo Degano \texttt{pierpaolo.degano@unipi.it}\\
Con Giulio Masetti \texttt{giulio.masetti@isti.snr.it}\\
Esame: compitini/scritto + orale
\pagebreak
\chapter{Calcolabilità}
\section{Teoria della Calcolabilità}
Illustra \textbf{cosa può essere calcolato da un computer} senza limitazioni di risorse come spazio, tempo ed energia. Vale a dire:
\begin{list}{-}{}
	\item Quali sono i \textbf{problemi \textit{solubili}} mediante una \textbf{procedura effettiva} (qualunque linguaggio su qualunque macchina)?
	\item Esistono \textbf{problemi \textit{insolubili}}? Sono interessanti, realistici, oppure puramente artificiali?
	\item Possiamo raggruppare i problemi in \textbf{classi}?
	\item Quali sono le \textbf{proprietà} delle classi dei problemi solubili?
	\item Quali sono le relazioni tra le classe dei problemi insolubili?
\end{list}
\paragraph{Astrazione} Utilizzeremo \textbf{termini astratti per descrivere la possibilità di eseguire un programma ed avere un risultato}. Questa astrazione è un \textbf{modello} che non tiene conto di dettagli al momento irrilevanti.\\
Un po' come l'equazione per dire quanto ci mette il gesso a cadere che non tiene conto delle forze di attrito dell'aria.
\paragraph{Problema della Decisione} Un problema è risolto se si conosce una \textbf{procedura} che permette di decidere con un numero \textbf{finito} di operazioni di decedere se una proposizione logica è vera o falsa.

\section{Algoritmo}
Un algoritmo è un insieme \textbf{finito} di istruzioni.
\paragraph{Istruzioni} Elementi da un insieme di \textbf{cardinalità finita} ed ognuna ha \textbf{effetto limitato} (localmente e "\textit{poco}") sui dati (che devono essere \textbf{discreti}). Un'istruzione deve richiedere tempo finito per essere elaborata.
\paragraph{Computazione} Successione di istruzioni finite in cui ogni passo dipende solo dai precedenti. Verificando una porzione finita dei dati (\textbf{deterministico}). Non c'è limite alla memoria necessaria al calcolo (è finita ma illimitata). Neanche il tempo è limitato (necessario al calcolo). Tanto tempo e tanta memoria quante ce ne servono.\\\\
Un'eccezione a questa definizione di algoritmo è costituita dalle macchine concorrenti/interattive, dove gli input variano nel tempo. Inoltre vi sono formalismi che tengono conto di algoritmi probabilistici e stocastici. Altre eccezioni sono gli algoritmi non deterministici, ma per ognuno di essi esiste un algoritmo deterministico equivalente (Teorema \texttt{3.3.6})
\pagebreak
\section{Macchina di Turing}
Introdotta da \textbf{Alan Turing} nel 1936, confuta la speranza "\textit{non ignorabimus}" di poter risolvere qualsiasi cosa con un programma.\\
Turing originariamente la presenta supponendo di aver un impiegato precisissimo ma stupido, con una pila di fogli di carta ed una penna, ed un foglio di carta con le istruzioni che esegue con estrema diligenza. Non capisce quello che fa, e si chiama "\textbf{computer}".

\paragraph{Struttura matematica} Una Macchina di Turing (MdT) è una quadrupla:
\begin{center}
M = (Q, $\sum$, $\delta$, q$_0$)
\end{center}
\begin{list}{}{}
	\item \textbf{Q} = \{q$_i$\} è l'insieme finito degli \textbf{stati} in cui si può trovare la macchina.\\
	Indicheremo con lo stato speciale \textit{h} la fine corretta della computazione, \textit{h} non $\in$ Q.
	\item $\sum$ = \{$\sigma$, $\sigma$'\ldots\} è l'insieme finito di \textbf{simboli}. 
	Ci sono elementi che devono per forza esistere:
	\begin{list}{}{}
		\item \textbf{\#} carattere \textbf{bianco}, vuoto
		\item $\triangleright$ carattere di inizio della memoria, chiamato \textbf{respingente}, che funziona come un inizio file
	\end{list}
	\item $\delta$ $\subseteq$ (Q $\times \sum$) $\rightarrow$ (Q' $\bigcup$ \{\textit{h}\}) $\times \sum$' $\times$ \{L, R, -\} è \textbf{funzione di transizione}.\\
	Mantiene determinismo perché funzione, ad un elemento associa un solo elemento (la transizione è univoca). Transizioni finite perché prodotto cartesiano di insiemi finiti.\\
$\delta$(q, $\triangleright$) = (q', $\triangleright$, R), cioè se sono a inizio file possono solo andare a destra.\\
Può essere vista come una relazione di transizione, $\delta \subseteq (Q \times \sum) \times (Q\:\bigcup\:\{\textit{h}\}) \times \sum \times \{L,\:R,\: -\}$
	\item q$_0 \in $ Q lo \textbf{stato iniziale} 
\end{list}
Mappatura a coda di rondine, bigezione tra (m, n) $\rightarrow$ k, cioè $N^2 \rightarrow N$.\\
Costruire un modello per il calcolo dopo aver posto delle condizioni affinché qualcosa si possa chiamare algoritmo.

\subsection{$\sum$}
\begin{list}{}{}
	\item $\sum^0$ = \{$\epsilon$\}, con $\epsilon =$ parola vuota, che non contiene caratteri
	\item $\sum^{i+1} = \sum \cdot \sum^i = \{\sigma \cdot u \:\:\vline\:\: \sigma \in \sum \:\wedge\: u \in \sum^i\}$
	\item $\sum^* = \bigcup_{i \in N}\sum^i$, insieme di tutte le possibili combinazioni di simboli
	\item $\sum^f = \sum^* \:\cdot\: (\sum \:-\: \{\#\} \:\bigcup\: \{\epsilon\})$, cioè linsieme di tutte le stringhe che terminano con un carattere non bianco ma può terminare con la stringa vuota
\end{list}
\paragraph{Esempio} $\sum_B = \{0, 1\} \longrightarrow \sum_B^* = \{\epsilon, 0, 1, 01, 10, 010, 110010, \ldots\}$ tutti i numeri binari

\subsection{Transizioni}
La \textbf{situazione corrente} di una macchina di Turing può essere scritto come $(q, u, \sigma, v)$ dove:
\begin{list}{}{}
	\item $q$ è lo \textbf{stato attuale}, $q \in Q$
	\item $u$ è la \textbf{stringa a sinistra} del carattere corrente, $u \in \sum^*$
	\item $\sigma$ è il \textbf{carattere corrente}, $\sigma \in \sum$
	\item $v$ è il \textbf{resto della stringa} che termina con un carattere non nullo, $v \in \sum^f$
\end{list}
Può anche essere più comodamente espressa come $(q, u \:\underline{\sigma}\: v)$

\subsection{Computazione}
Una computazione è una transizione $(q, x) \longrightarrow (q', \omega)$. Una macchina di Turing parte \textbf{sempre} da $(q_0, \underline{\triangleright} x)$.\\
Ogni computazione può esprimere il numero di passi necessari, ad esempio $\gamma \longrightarrow^n \gamma'$.\\
$\forall \:\:computazione\:\: \gamma \Rightarrow \gamma \longrightarrow^0 \gamma$. Inoltre se $\gamma \longrightarrow \gamma' \wedge \gamma' \longrightarrow^n \gamma''$ allora $\gamma \longrightarrow^{n+1} \gamma''$

\pagebreak

\paragraph{Esempio} Macchina di Turing che esegue la semplice somma di due semplici numeri romani.
\begin{multicols}{2}
\begin{center}
	\begin{tabular}{c | c | c}
		$q$ & $\sigma$ & $\delta(q, \sigma)$\\
		\hline
		$q_0$ & $\triangleright$ & $(q_0, \triangleright, R)$ \\
		$q_0$ & I & $(q_0, I, R)$ \\
		$q_0$ & $+$ & $(q_1, I, R)$ \\
		\hline
		$q_1$ & I & $(q_1, I, R)$ \\
		$q_1$ & \# & $(q_2, \#, L)$ \\
		\hline
		$q_2$ & I & $(h, \#, -)$ \\
	\end{tabular}
\end{center}
\columnbreak
$(q_0, \underline{\triangleright}II+III) \longrightarrow (q_0, \triangleright \underline{I}I+III) \longrightarrow (q_0, \triangleright I \underline{I}+III) \longrightarrow (q_0, \triangleright II \:\underline{+}\: III) \longrightarrow (q_1, \triangleright III\underline{I}II) \longrightarrow (q_1, \triangleright IIII \underline{I}I) \longrightarrow (q_1, \triangleright IIIII\underline{I}) \longrightarrow (q_1, \triangleright IIIIII\underline{\#}) \longrightarrow (q_2, \triangleright IIIII\underline{I}) \longrightarrow (h, \triangleright IIIII)$
\end{multicols}

\paragraph{Esempio} Macchina di Turing che verifica se una stringa di lettere $a, b$ è palindroma o no.
\begin{multicols}{2}
\begin{center}
	\begin{tabular}{c | c | c}
		$q$ & $\sigma$ & $\delta(q, \sigma)$\\
		\hline
		$q_0$ & $\triangleright$ & $(q_0, \triangleright, R)$ \\
		$q_0$ & $a$ & $(q_A, \triangleright, R)$ \\
		$q_0$ & $b$ & $(q_B, \triangleright, R)$ \\
		$q_0$ & $\#$ & $(h, \#, -)$ \\
		\hline
		$q_A$ & $a/b$ & $(q_A, a/b, R)$ \\
		$q_A$ & \# & $(q_{A'}, \#, L)$ \\
		\hline
		$q_{A'}$ & $a$ & $(q_R, \#, L)$ \\
		\hline
		$q_B$ & $a/b$ & $(q_B, a/b, R)$ \\
		$q_B$ & \# & $(q_{B'}, \#, L)$ \\
		\hline
		$q_{B'}$ & $a$ & $(q_R, \#, L)$ \\
		\hline
		$q_R$ & $a/b$ & $(q_R, a/b, R)$ \\
		$q_R$ & $\triangleright$ & $(q_0, \triangleright, R)$ \\
	\end{tabular}
\end{center}
\columnbreak
$(q_0, \underline{\triangleright}abba) \longrightarrow (q_0, \triangleright \underline{a}bba) \longrightarrow (q_A, \triangleright\triangleright \underline{b}ba) \longrightarrow \\ (q_A, \triangleright \triangleright b\underline{b}a) \longrightarrow (q_A, \triangleright \triangleright bb\underline{a}) \longrightarrow (q_A, \triangleright  \triangleright bba\underline{\#}) \longrightarrow \\ (q_{A'}, \triangleright \triangleright bb\underline{a}) \longrightarrow (q_R, \triangleright \triangleright b\underline{b}) \longrightarrow (q_R, \triangleright \triangleright \underline{b}b) \longrightarrow (q_R, \triangleright \underline{\triangleright} bb) \\ \longrightarrow (q_0, \triangleright \triangleright \underline{b}b) \longrightarrow (q_B, \triangleright \triangleright \triangleright \underline{b}) \longrightarrow (q_B, \triangleright \triangleright \triangleright b\underline{\#}) \longrightarrow \\ (q_{B'}, \triangleright \triangleright \triangleright \underline{b}) \longrightarrow (q_R, \triangleright \triangleright \underline{\triangleright})  \longrightarrow (h, \triangleright \triangleright \triangleright)$
\end{multicols}
\section{Linguaggi di Programmazione}
Un primo formalismo di algoritmo, come abbiamo visto, è la \textbf{macchina di Turing}: attenendosi alle richieste di tempo e spazio arbitrariamente grandi ma finiti, risolve un \textbf{problema}.\\
Un secondo formalismo sono i \textbf{linguaggi di programmazione}.
\subsection{Sintassi}
\paragraph{Sintassi astratta} Definiamo la \textbf{sintassi} dello scheletro di un semplice linguaggio di programmazione imperativo.\\
Una \textbf{sintassi astratta} è una sintassi non concreta, cioè che non tiene conto di alcune cose come la procedenza tra gli operatori.\\
\begin{list}{}{\textbf{Sintassi}}
	\item Expr $\rightarrow$ E ::= x $\vline\:$ n $\vline\:$ E + E $\vline\:$ E $\cdot$ E $\vline\:$ E - E
	\item Bexpr $\rightarrow$ B ::= tt $\vline\:$ ff $\vline\:$ E $<$ E $\vline\:$ $\neg$B $\vline\:$ B $\vee$ B
	\item Comm $\rightarrow$ C ::= skip $\vline\:$ x $=$ E $\vline\:$ C;C $\vline\:$ if B then C else C $\vline\:$ for i = E to E do C $\vline\:$ while B do C
\end{list}
\begin{list}{}{Abbiamo una serie di insiemi da definire ulteriormente}
	\item x $\in$ Var, l'insieme delle \textbf{variabili}
	\item n $\in$ $N$, \textbf{numeri naturali}.
\end{list}
\begin{list}{}{Abbiamo anche la \textbf{memoria} per poter \textbf{assegnare ad una variabile il suo significato}}
	\item $\sigma$ : Var $\rightarrow_{fin} N$\\
	Si dice "a dominio finito", indicata dal $fin$ sotto la freccia, per indicare che il dominio Var ha cardinalità finita. Var dominio è quindi un sottoinsieme di Var insieme delle variabili che sarebbe infinito.\\
	La memoria si può aggiornare, diventando $\sigma'$ = $\sigma[$x$\:\mapsto\:$n$]$.\\Ad esempio, $\sigma'(y)$ = n se y = x, altrimenti $\sigma'(y)$ = $\sigma(y)$
\end{list}
\pagebreak
\subsection{Funzioni di Valutazione}
\begin{list}{}{Inoltre, per valutare le espressioni generate dalla grammatica, servono delle \textbf{funzioni di valutazione}. Esse \textbf{trovano il significato di ogni espressione}}
	\item Funzione di valutazione delle espressioni\\$\mathscr{E}$ : Expr $\times$ (Var $\rightarrow N$) $\rightarrow N$\\La sua \textbf{semantica denotazionale} è la seguente
	\begin{multicols}{2}
	\begin{list}{}{}
		\item $\mathscr{E}[$x$]_\sigma$ = $\sigma$(x)
		\item $\mathscr{E}[$n$]_\sigma$ = n
		\item $\mathscr{E}[$E$_1$ $\pm$ E$_2]_\sigma$ = $\mathscr{E}[$E$_1]_\sigma$ $\pm$ $\mathscr{E}[$E$_2]_\sigma$
	\end{list}
	\end{multicols}
	Importante notare come gli operatori $+$, $-$, $\cdot$ \textit{dentro} le espressioni siano dei \textbf{semplici token denotazionali}, mentre sono gli operatori \textit{valutati} ad eseguire il vero e proprio calcolo. Per chiarire questo aspetto, facciamo un esempio. Valutiamo con la nostra funzione $\mathscr{E}[$E$_1$ $+$ E$_2]_\sigma$ = $\mathscr{E}[$E$_1]_\sigma$ \textit{più} $\mathscr{E}[$E$_2]_\sigma$. Se non definiamo l'operatore "\textit{più}", allora se poniamo $\sigma$(x) = 25 la valutazione
	\begin{list}{}{}
		\item $\mathscr{E}[$3 + x$]_\sigma$ = $\mathscr{E}[$3$]_\sigma$ \textit{più} $\mathscr{E}[$x$]_\sigma$ = 3 \textit{più} 25 = 42
	\end{list}
	è corretta quanto
	\begin{list}{}{}
		\item $\mathscr{E}[$3 + x$]_\sigma$ = $\mathscr{E}[$3$]_\sigma$ \textit{più} $\mathscr{E}[$x$]_\sigma$ = 3 \textit{più} 25 = 28
	\end{list}
	Ovviamente utilizzeremo la valutazione specificata in precedenza e gli operatori aritmetici assumeranno il loro significato standard.\\
	L'unica eccezione è l'operatore $-$, che nel nostro caso sarà il \textbf{meno limitato} dal simbolo $\dot{-}$, la cui unica differenza è che non può dare un risultato inferiore a 0. Ad esempio, 5 $\dot{-}$ 7 = 0
	\item Funzione di valutazione di espressioni booleane\\$\mathscr{B}$ : Bexpr $\times$ (Var $\rightarrow N$) $\rightarrow$ \{tt, ff\}\\
	La cui \textbf{semantica denotazionale} è la seguente
	\begin{multicols}{2}
	\begin{list}{}{}
		\item $\mathscr{B}[$tt$]_\sigma$ = tt
		\item $\mathscr{B}[$ff$]_\sigma$ = ff
		\item $\mathscr{B}[$E$_1 <$ E$_2]_\sigma$ = $\mathscr{E}[$E$_1]_\sigma$ $<$ $\mathscr{E}[$E$_2]_\sigma$
		\item $\mathscr{B}[\neg$B$]_\sigma$ = $\neg\mathscr{B}[$B$]_\sigma$
		\item $\mathscr{B}[$B$_1 \vee$ B$_2]_\sigma$ = $\mathscr{B}[$B$_1]_\sigma$ $\vee$ $\mathscr{B}[$B$_2]_\sigma$
	\end{list}
	\end{multicols}
	Anche qua vale il medesimo discorso sulla definizione sugli effettivi operatori.
\end{list}
\subsection{Semantica Operazione Strutturale}
\paragraph{Structural Operationale Semantics} Metodo attraverso il quale viene fornita la semantica dei comandi. Parte da un \textbf{insieme di configurazioni $\Gamma$}
\begin{list}{}{}
	\item $\Gamma$ = \{(C, $\sigma$) $\vline\:$ FV(C) $\subset$ dom($\sigma$)\} $\cup$ \{$\sigma$\}
\end{list}
dove FV(C) sono le \textbf{variabili del programma} e con FV(C) $\subset$ dom($\sigma$) si richiede che tutte le variabili del programma abbiano un valore nella memoria fornita. Si fa l'unione con la sola memoria $\sigma$ perché la situazione finale è (  , $\sigma$) che, analogamente allo stato fittizio $h$ nella macchina di Turing, segnala la fine dell'esecuzione. Inoltre si hanno le \textbf{transizioni $\rightarrow$}
\begin{list}{}{}
	\item $\rightarrow \:\subset \Gamma \times \Gamma$
\end{list}
Definiamo quindi un \textbf{insieme di transizioni ($\Gamma$, $\rightarrow$)} tramite delle \textbf{regole di inferenza} del tipo $\frac{premesse}{conclusione}$. In assenza di premesse, $-$, la regola di inferenza si dice \textbf{assioma}.
\begin{multicols}{2}
	$$\frac{-}{(skip, \sigma) \rightarrow \sigma}$$
	$$\frac{-}{(x = E, \sigma) \rightarrow \sigma[x\:\mapsto\:n]}\mathscr{E}[E]_\sigma = n$$
	$$\frac{(C_1, \sigma) \rightarrow (C_1', \sigma')}{(C_1;C_2, \sigma) \rightarrow (C_1';C_2, \sigma')}$$
	$$\frac{-}{(if\:\: B\:\: then\:\: C_1\:\: else\:\: C_2, \sigma) \rightarrow(C_1, \sigma)}\mathscr{B}[B]_\sigma = tt$$
	$$\frac{-}{(if\:\: B\:\: then\:\: C_1\:\: else\:\: C_2, \sigma) \rightarrow(C_2, \sigma)}\mathscr{B}[B]_\sigma = ff$$
	$$\frac{-}{(for\:\: i = E_1\:\: to\:\: E_2\:\: do\:\: C, \sigma) \rightarrow \sigma}\mathscr{B}[E_2 < E_1]_\sigma = tt$$
\end{multicols}
	$$\frac{-}{(for\:\: i = E_1\:\: to\:\: E_2\:\: do\:\: C, \sigma) \rightarrow (i = n_1;\:\:C;\:\:for\:\: i = n_1 + 1\:\:to\:\:n_2\:\:do\:\:C, \sigma)}\mathscr{B}[E_2 < E_1]_\sigma = ff\: \wedge\: \mathscr[E_1]_\sigma = n_1 \wedge\: \mathscr[E_2]_\sigma = n_2$$
	$$\frac{-}{(while\:\:B\:\:do\:\:C, \sigma) \rightarrow (if\:\:B\:\:then\:\:C;\:\:while\:\:B\:\:do\:\:C,\sigma)} $$
\section{Calcolabilità}
\subsection{T-Calcolabile}
Dati $\Sigma$ alfabeto della macchina, $\Sigma_0$ alfabeto di input e $\Sigma_1$ alfabeto di output, con \#, $\triangleright \not\in \Sigma_0 \cup \Sigma_1 \subset \Sigma$
\begin{center}
M=(Q, $\Sigma$, $\delta$, q$_0$) calcola $f$ : $\Sigma_0^* \longrightarrow \Sigma_1^*$ $\Leftrightarrow$ ($\forall w \in \Sigma_0^* \wedge f(w) = x \Rightarrow M(w) \rightarrow_{fin}$ (h, $\triangleright$z)$)$
\end{center}
Si dice che la \textbf{funzione} $f$ è \textbf{T-Calcolabile}.\\
Cioè, esiste una macchina di Turing che per ogni stringa finita in input arriva, con un numero finito di passi, all'arresto lasciando sul nastro la stringa di output corretta. Notare come non viene data nessuna interpretazione al risultato della $f$.
\subsection{\texttt{while}-Calcolabile}
\begin{center}
C calcola $f$ : Var $\rightarrow$ $N$ $\Leftrightarrow$ ($\forall\:\: \sigma$ : Var $\rightarrow$ $N$ $\wedge$ $f(x) = n$ $\Rightarrow$ C($\sigma$) $\rightarrow_{fin}$ $\sigma'$ $\wedge$ $\sigma'(x) = n$)
\end{center}
Si dice che la funzione $f$ è \textbf{\texttt{while}-Calcolabile}.\\
Cioè esiste un programma C che calcola il risultato corretto in un numero finito di passi.
\paragraph{Invariante} Tutti i risultati visti fin'ora \textbf{sono invarianti rispetto al modello dei dati}, e questo vale anche per la T-Calcolabilità e la \texttt{while}-Calcolabilità.\\
In particolare, se ho i dati in un formato A allora posso codificarli nel formato B in cui opera la macchina, calcolare il risultato in formato B e decoficarlo nel formato A di partenza. Questo vale se \textbf{le codifiche sono funzioni biunivoche e "\textit{facili}"}. Vedremo cosa significa essere "facili", ma per adesso basti pensare ad un numero finito di passi e che terminano sempre.
\subsection{Esempio di codifica}
\begin{multicols}{2}
\begin{center}
	\begin{tabular}{c || c | c | c | c | c | c}
	 & 0 & 1 & 2 & 3 & 4 & 5 \\
	 \hline
	 \hline
	 0 & 0 & 2 & 5 & 9 & 14 & \\
	 \hline
	 1 & 1 & 4 & 8 & 13 & & \\
	 \hline
	 2 & 3 & 7 & 12 & & & \\
	 \hline
	 3 & 6 & 11 & \ldots & & & \\
	 \hline
	 4 & 10 & 16 & & & & \\
	 \hline
	 5 & 15 & & & & & 
	\end{tabular}\\
	Codifica a coda di rondine
\end{center}
\columnbreak
\paragraph{Codifica} ($x$, $y$) $\mapsto$ $\frac{1}{2}$($x^2 + 2xy + y^2 + 3x + y$)\\
Es. (3, 1) $\mapsto$ $\frac{1}{2}$($9 + 6 + 1 + 9 + 1$) = $\frac{26}{2}$ = 13
\paragraph{Decodifica} $n$ $\mapsto$ ($n - \frac{1}{2}k(k + 1)$, $k - (n - \frac{1}{2}k(k+1))$) con $k = \lfloor\frac{1}{2}(\sqrt{1 + 8n} -1)\rfloor$\\\\
Es 8 $\mapsto$ ($8 - 6$, $6 - 8 + 3$) = ($2$, $1$)\\
$k = \lfloor\frac{1}{2}\sqrt{1 + 8\cdot 8} - 1\rfloor = 3$\\
$\frac{k(k+1)}{2} = 6$
\end{multicols}
\pagebreak
\section{Notazione}
Una \textbf{funzione} $f$ è $\subset$ A $\times$ B, con A spazio di partenza e B codominio. Quindi $f$(a) = b si può esprimere anche con (a, b) $\in$ $f$, con a $\in$ A e b $\in$ B.
\begin{list}{}{}
	\item $f$(a) = b $\wedge$ $f$(a) = c $\Rightarrow$ b = c
	\item Considereremo \textbf{funzioni parziali}, cioè funzioni con A contenente punti dove $f$ non è definita. Non è quindi detto che $\forall$ a $\in$ A $\exists$ b $\in$ B \vline $\:\:f$(a) = b
	\item $f$ \textbf{converge} su a, cioè $f$(a)$\downarrow$ $\Leftrightarrow$ $\exists$ b $\vline\:$ $f$(a) = b
	\item $f$ \textbf{diverge} su a, cioè $f$(a)$\uparrow$ $\Leftrightarrow$ $\not\exists$ b $\vline\:$ $f$(a) = b
	\item \textbf{Dominio} di $f$: $dom(f)$ = \{a \vline$\:\: f$(a)$\downarrow$\}
	\item \textbf{Immagine} di $f$: $imm(f)$ = \{b \vline$\:\: \exists$ a $\in$ A $\Rightarrow$ $f$(a) = b\}
\end{list}
\paragraph{Rapporto tra algoritmi A e funzioni $f$} $f$ è un \textbf{insieme potenzialmente infinito di coppie}, ma non posso assegnare due $f$ diverse allo stesso insieme, mentre esistono tanti algoritmi diversi che calcolano la stessa funzione.\\
Ad esempio, $f$ = $\emptyset$ è calcolata da \texttt{while(true) do skip} ma anche da \texttt{while(true) do skip;skip}.
\begin{enumerate}
	\item Quali sono le funzioni calcolabili?\\
	Nelle ipotesi iniziali di definizione di algoritmo, per adesso conosciamo le T-Calcolabili e le \texttt{while}-Calcolabili.
	\item Quali proprietà hanno?\\
	Posso combinarle?
	\item Esistono funzioni non calcolabili?
	\item Sono interessanti?\\
	Esistono a prescindere dalla macchina?
\end{enumerate}
\paragraph{Algoritmi e calcolabilità} Per ora abbiamo definito gli algoritmi in base al loro comportamento, sotto forma di \textbf{configurazioni che si susseguono} del tipo (istr. corrente + \ldots, memoria). Abbiamo anche diversi modi di affrontare la calcolabilità:
\begin{enumerate}
	\item \textbf{Hardware}, con la macchina di Turing\\
	Questo è uno dei primi esempio di calcolo, è semplice da capire e si descrivono direttamente macchina che eseguono gli algoritmi. Uno dei primi approcci allo studio della complessità.\\
	\textbf{Cambio programma $\rightarrow$ Cambio macchina}
	\item \textbf{Software}\\
	Ho l'interprete, cioè la semantica, fissi. Se cambio il programma non devo cambiare la macchina
	\begin{enumerate}
		\item Programmi \texttt{while}\\
		Base della programmazione iterativa, dalla semantica operazionale e anch'essi usati per lo studio della complessità
		\item Funzioni ricorsive\\
		Base della programmazione funzionale
	\end{enumerate}
\end{enumerate}
\pagebreak
\section{Funzioni ricorsive primitive}
Per formalizzare i vari modi con cui possiamo esprimere le funzioni, usiamo quella che si chiama \textbf{$\lambda$-notazione}. Queste espressioni individuano gli argomenti all'interno di un'espressione che descrive una funzione, scritta seguendo un'opportuna sintassi.
$$\lambda <\textsl{variabili}>.<\textsl{espressione}>$$
\paragraph{Esempio} $\lambda\,x,\,y.\textsl{expr}$\\
Gli \textbf{argomenti} dell'espressione $\textsl{expr}$ sono $x$, $y$. Si dice anche che $x$, $y$ \textbf{appaiono legate da $\lambda$ in $\textsl{expr}$}.\\
Invece un qualsiasi altro simbolo di variabile $w$ in \textsl{expr} \textbf{non è da considerarsi argomento} dell'espressione, e viene definito \textbf{libero} in \textsl{expr}.\\
Altri \textbf{esempi} per evidenziare la \textbf{notazione}:
\begin{list}{}{}
	\item $\lambda\, y. x + y$
	\item $\lambda\, x \lambda\, y.x + y$ che può essere riscritta come $\lambda\, x,\,y.x + y$ ed equivale a dire $somma(x, y) = x + y$ dando così il nome $somma$ alla funzione.
	\item $\lambda\, x_1, x_2, \ldots, x_n.\textsl{expr}$ riscritta come $\lambda\, \overrightarrow{x}.\textsl{expr}$
\end{list}
\subsection{Classe C}
La classe $C$ delle \textbf{funzioni ricorsive primitive} è la \textbf{minima classe} di funzioni che obbediscono alle seguenti regole di inferenza, regole di sintassi per definire le funzioni.\\
\begin{list}{}{\textbf{Casi base}}
	\item \textbf{Zero}: $\lambda \overrightarrow{x}.0$\\
	Prende un vettore di argomenti e restituisce 0.
	\item \textbf{Successore}: $\lambda x.x+1$\\
	Prende un valore e restituisce il suo successore.
	\item \textbf{Proiezione}/\textbf{Identità}: $\lambda \overrightarrow{x}.x_i$\\
	$\overrightarrow{x} = x_1,\ldots, x_n$, $1 \leq i \leq n$
\end{list}
\begin{list}{}{\textbf{Casi iterativi}}
	\item \textbf{Composizione}\\
	$g_1,\ldots, g_n \in C$ con $k$ argomenti ("a $k$ posti") e\\
	$h \in C$ a $n$ posti\\
	$\Rightarrow \lambda x_1, \ldots, x_n.h(g_1(\overrightarrow{x}),\ldots, g_n(\overrightarrow{x})) \in C$
	\item \textbf{Ricorsione primitiva}\\
	$h \in C$ a $n + 1$ posti e\\
	$g \in C$ a $n - 1$ posti\\
	$\Rightarrow$
	\begin{math}
		\left\{
		\begin{array}{l}
			f(0, x_2, \ldots, x_n) = g(x_2, \ldots, x_n)\\
			f(x_1 + 1, x_2, \ldots, x_n) = h(x_1, f(x_1, x_2, \ldots, x_n), x_2,\ldots, x_n)
		\end{array}
		\right.
	\end{math}
\end{list}
$f \in C \Leftrightarrow$ esiste una successione $f_0,\ldots,\,f_n = f\:\:\vline\:\:\forall f_1$ è ottenuto con i casi base oppure $f_i$ è ottenuto con i casi iterativi da $f_j$ con $j < i$
\pagebreak
\paragraph{Esempio} Esempio di funzioni ricorsive\\
$f_1 = \lambda x.x$\\
$f_2 = \lambda x.x+1$\\
$f_3 = \lambda x_1, x_2, x_3. x_2$\\
$f_4 = f_2(f_3(x_1, x_2, x_3))$\\
\begin{math}
		\left\{
		\begin{array}{l}
			f_5(0, x_2) = f_1(x_2)\\
			f_5(x_1 + 1, x_2) = f_4(x_1, f_5(x_1, x_2), x_2)
		\end{array}
		\right.
\end{math}\\\\
Proviamo a calcolare $f_5(2, 3) =$
\begin{multicols}{2}
\textbf{Regola di valutazione interna-sinistra}: valuto per primo quello che sta dentro i parametri partendo da sinistra.\\
$= f_5(1 + 1, 3) =$\\
$= f_4(1, \underline{f_5(1, 3)}, 3) =$\\
$= f_4(1, f_4(0, \underline{f_5(0, 3)}, 3), 3) =$\\$= f_4(1, f_4(0, \underline{f_1(3)}, 3), 3) =$\\
$= f_4(1,\underline{f_4(0, 3, 3)}, 3) =$\\
$= f_4(1, f_2(\underline{f_3(0, 3, 3)}), 3) =$\\
$= f_4(1, \underline{f_2(3)}, 3) =$\\
$= \underline{f_4(1, 4, 3)} =$\\
$= f_2(\underline{f_3(1, 4, 3)}) = $\\
$= \underline{f_2(4)} =$\\
$= 5$\\
\columnbreak

Vediamo cosa succede con una \textbf{regola di valutazione esterna}:
$f_5(2, 3) =$\\
$= \underline{f_4( 1, f_5(1, 3), 3)} =$\\
$= \underline{f_2(f_3(1, f_5(1, 3), 3))} =$\\
$= \underline{f_3(1, f_5(1, 3), 3)} + 1 =$\\
$= \underline{f_5(1, 3)} + 1 =$\\
$= \underline{f_4(0, f_5(0, 3), 3)} + 1 =$\\
$= \underline{f_2(f_3(0, f_5(0, 3), 3)} + 1 = $\\
$= \underline{f_3(0, f_5(0, 3), 3)} + 1 + 1 =$\\
$= \underline{f_5(0, 3)} + 2 =$\\
$= \underline{f_1(3)} + 2 =$\\
$= 3 + 2 =$\\
$= 5$
\end{multicols}

\begin{multicols}{2}
\paragraph{Meno Limitato} Non ritorna mai numeri negativi, ma 0.\\
$f_7(x, y) = y$\\\\
$f_8(x, y) = x$\\\\
\begin{math}
		\left\{
		\begin{array}{l}
			pred(0) = 0\\
			pred(x + 1) = f_8(x, pred(x))
		\end{array}
		\right.
\end{math}\\\\
$f_9(x, y, z) = pred(f_3(x, y, z)$\\\\
\begin{math}
		\left\{
		\begin{array}{l}
			f_{10}(0, y) = f_1(y)\\
			f_{10}(x + 1, y) = f_9(x, f_{10}(x, y), y)
		\end{array}
		\right.
\end{math}\\\\
$\Rightarrow x \dot{-} y = f_{10}(f_7(x, y), f_8(x, y))$
\columnbreak
\paragraph{Somma}
Non è altro che generalizzazione del successore, applico il successore tante volte quante servono.\\\\
\begin{math}
		\left\{
		\begin{array}{l}
			0 + y = y\\
			(x + 1) + y = (x + y) + 1
		\end{array}
		\right.
\end{math}
\paragraph{Prodotto}
Sfrutto la somma\\\\
\begin{math}
		\left\{
		\begin{array}{l}
			0 * y = 0\\
			(x + 1) * y = (x * y) + y)
		\end{array}
		\right.
\end{math}
\paragraph{Potenza}
Generalizza il prodotto\\\\
\begin{math}
		\left\{
		\begin{array}{l}
			x^0 = 1\\
			x^{y + 1} = (x^y) * x\\
		\end{array}
		\right.
\end{math}\\\\
C'è un modo per generalizzare la potenza? $\Rightarrow$ \textbf{Ackerman}.
\end{multicols}

\paragraph{Relazione} Diciamo che la relazione $R(x_1,\ldots,\,x_n) \subset N^n$ è \textbf{ricorsiva primitiva} se lo è la sua \textbf{funzione caratteristica} $\chi_R$ definita come\\
\begin{math}
\chi_R(x_1,\ldots, x_n) = 
		\left\{
		\begin{array}{l}
			1 \:\:\:\:\textsl{se}\:\: (x_1, \ldots, x_n) \in R\\
			0 \:\:\:\:\textsl{se}\:\: (x_1, \ldots, x_n) \not\in R
		\end{array}
		\right.
\end{math}\\\\
Quindi se $\chi_R$ è ricorsiva primitiva allora anche $R$ è ricorsiva primitiva.

%TODO note1.pdf, p. 28
\paragraph{Esempio} $P =$ \{ $n \in N\:\:\vline$ $n$ è un numero primo\} è ricorsiva primitiva. Questo per il teorema di fattorizzazione unica.\\
$\forall x \in N\:\:\exists$ numero finito di esponenti $x_1 \neq 0\:\:\vline\:\: x = p_0^{x_1}\cdot p_1^{x_1}\cdot\ldots\cdot p_n^{x_n}$\\
Come trovare tali esponenti con $f$ ricorsiva primitiva.\\
M = (Q, $\Sigma$, $\delta$, q$_0$)\\
Q = \{q$_0$, \ldots, q$_k$), $\Sigma$ = \{$\sigma_0$, \ldots, $\sigma_n$)\\
\textbf{Kurt G\"{o}del}: rappresentare algoritmi come numeri: \textbf{G\"{o}delizzazione} data macchina di turing M trovo $i$ che è il suo numero di G\"{o}del.
\subsection{Funzione di Ackermann}
La funzione di Ackermann \textbf{non è definibile} mediante gli schemi di ricorsione primitiva definiti in precedenze, ma è totale ed ha una definizione intuitivamente accettabilissima.

\begin{list}{}{}
	\item $A(0, 0, y) = y$
	\item $A(0, x + 1, y) = A(0, x, y) + 1$
	\item $A(1, 0, y) = 0$
	\item $A(z + 2, 0, y) = 1$
	\item $A(z + 1, x + 1, y) = A(z, A(z + 1, x, y), y)$ \textbf{doppia ricorsione}

\end{list}
La \textbf{doppia ricorsione} presente non è un problema: tutti i valori su cui si ricorre decrescono, quindi i valori di $A(z, x, y)$ sono definiti in termini di un numero finito di valori della funzione $A$. Quindi intuitivamente $A$ è calcolabile. Inoltre \textbf{cresce più rapidamente di ogni funzione ricorsiva primitiva} ma \textbf{non è ricorsiva primitiva}.\\
Ma cosa calcola? Una sorta di esponenziale generalizzato, infatti:
\begin{list}{}{}
	\item $A(0, x, y) = y + x$
	\item $A(1, x, y) = y * x$
	\item $A(2, x, y) = y^x$
	\item $A(3, x, y) = y^{\left.y^{\ldots^y}\right\} \:x\:\textsl{volte}}$
\end{list}
\subsection{Realizzazione}
Con il linguaggio-\texttt{while} e il linguaggio-\texttt{for} posso riprodurre i casi base della ricorsione. In particolare, per ogni programma \texttt{for} esiste una funzione ricorsiva primitiva e viceversa.\\
\begin{list}{}{}
	\item Un programma che calcola lo $0$ è un programma che legge gli ingressi e scrive $0$ in uscita.
	\item Il successore lo realizzo con un assegnamento uscita $=$ ingresso $ + 1$
	\item La proiezione consiste nel leggere in memoria la variabile $x_i$ cercata e metterla in uscita
	\item Realizzo $h$ tale che $h(g_1(x, y, z), g_2(x, y, z))$, con programma $p_1$ associato a $g_1$, $p_2$ associato a $g_2$ e $p_3$ associato a $h$.\\
Il programma che realizza la composizione sarà quindi $p_1$;$p_2$;$p_3$.\\
	\item Per la ricorsione primitiva
	\begin{math}
		\left\{
		\begin{array}{l}
			f(0, y) = g(y) \rightarrow p_1\\
			f(x + 1, y) = h(x, f(x, y), y) \rightarrow p_2
		\end{array}
		\right.
	\end{math}
	che dopo qualche passaggio abbiamo visto che\\$f(x + 1, y) =  h(x, f(x, y), y) = h(x, h(x + 1, f( x + 1, y)), y)$. Associando $p_1$ a $g$ e $p_2$ a $h$, lo realizzo con il programma-\texttt{for}
	\begin{lstlisting}
t1 = g(y);
for (i = 1 to x + 1):
	t1 = g(i, t1, y);
end
	\end{lstlisting}
\end{list}
Per la \textbf{funzione caratteristica} $\chi_I(n) =$
\begin{math}
		\left\{
		\begin{array}{l}
			1\:\: n \in I\\
			0\:\:\textsl{altrimenti}
		\end{array}
		\right.
\end{math}
\pagebreak
\section{Diagonalizzazione}
\paragraph{Esiste un formalismo che esprime tutte e sole le funzioni totali calcolabili?} \textbf{No}\\
Dobbiamo necessariamente avere a che fare con funzioni parziali, ma perché "no"?\\
\textbf{Qualunque formalismo o esprime solo funzioni totali ma non tutte, oppure esprime anche funzioni parziali}. La dimostrazione è fondamentale per la teoria della calcolabilità: prende il nome di \textbf{diagonalizzazione}.
\subparagraph{Dimostazione} Fissiamo il formalismo delle funzioni ricorsive primitive, posso prendere l'algoritmo di G\"{o}del per numerarle. Quindi avrò $f_0$, $f_1$, \ldots, $f_n$, \ldots\\
Definisco $g(n) = f_n(n) + 1$ (\textit{diagonalizzazione} viene da usare lo stesso indice per indice e parametro).\\
Se $g$ è una ricorsiva primitiva, allora è numerabile. Diciamo che $g$ ha come numero $i$: $f_i(n) = g(n) = f_n(n) + 1$\\
Se diagonalizzo avrò $f_i(i) = g(i) = f_i(i) + 1$ ma \textbf{non può essere} che $f_i(i) = f_i(i) + 1$\\
$\Rightarrow g$ non è ricorsiva primitiva.\\\\
Se io prendo le funzioni parziali, posso applicare lo stesso ragionamento?\\
$\phi(x) = \psi_x(x) + 1$\\
Diciamo come prima che $\phi(x)$ ha indice $i$, quindi $\psi_i(x) = \phi(x) = \psi_x(x) + 1$\\
Se $\psi_i(x)$ diverge, allora $\psi_x(x)$ diverge e anche $\psi_x(x) + 1$ diverge, quindi sono uguali. Non si applica il ragionamento della diagonalizzazione nel caso delle funzioni parziali.
\section{$\mu$-ricorsive}
Minima classe $\mathscr{R}$ che, allo schema fino alla ricorsione primitiva, si aggiunge:
\paragraph{Minimizzazione} $\phi(\overrightarrow{x}, y) \in \mathscr{R}$\\
$\psi(\overrightarrow{x}) = \mu y.[\phi(\overrightarrow{x}, y) = 0 \wedge \forall z < y\:\:\vline\:\: \phi(\overrightarrow{x}, z)\downarrow] $\\
$\mu x.[I]$ è il minimo elemento di $I$ insieme.\\\\
Cosa significa? Data una funzione appartenente a $\mathscr{R}$ (che ovviamente può essere una ricorsiva primitiva), la vado a calcolare sugli argomenti $\overrightarrow{x}$ della $\psi$ e su una certa $y$. Se vale 0, il risultato è $y$, altrimenti \textbf{deve} convergere e vado avanti incrementando $y$ di 1 e ricalcolando fino a che non trovo un risultato pari a 0.\\
Quindi le $\mu$-ricorsive definiscono anche funzioni non totali, al contrario delle ricorsive primitive che definiscono solo funzioni totali.
\subparagraph{Esempio} $\phi(x, y) = 42$ è costante, quindi ricorsiva primitiva, quindi anche $\mu$-ricorsiva.\\
$\psi(x) = \mu y.[\phi(x, y) = 42]$ ovunque indefinita perché non tornerà mai 0 quindi $\not\exists y$.\\\\
Quindi \textbf{terminazione e non terminazione sono cruciali}.\\
Se la definisco per casi? Ad esempio 
\begin{math}
	f(x) = \left\{
	\begin{array}{c c}
	\mu y.[y < g(x)\:\:\vline\:\: h(x, y) = 0] & \textsl{se}\:\exists\:\textsl{tale} y\\
	0 & \textsl{altrimenti}
	\end{array}
	\right.
\end{math}
con $g$, $h$ ricorsive primitive.\\$f$ è ricorsiva primitiva, perché composizione di ricorsive primitive, ed è anche totale, perché converge sempre.\\
Quindi \textbf{se pongo dei limiti al numero di tentativi}, dato da $y < g(x)$, si ricade nelle ricorsive primitive e non ci sono problemi di parzialità.
\subsection{Notazione}
Per ragioni storiche, una relazione $I \subset N^n$ è \textbf{ricorsiva} (sinonimo di totale) $\Leftrightarrow$ la sua funzione caratteristica $\chi_I$ è \textbf{calcolabile totale}.\\
Inoltre, come già detto, $I$ è ricorsiva primitiva $\Leftrightarrow$ $\chi_I$ è ricorsiva primitiva.
\pagebreak
\section{Tesi di Church-Turing}
\textbf{Le funzioni intuitivamente calcolabili sono tutte e sole le T-calcolabili}.\\
In realtà è un'ipotesi, ma è così forte che viene presa come tesi. Ci permette di dimenticarci il formalismo con cui formalizziamo gli algoritmi, poiché tutti i formalismi rappresentano la stessa \textit{classe}. Ci limiteremo a dire algoritmo, Macchia di Turing\ldots$\,$ indifferentemente, poiché un algoritmo è equivalente qualsiasi sia il linguaggio in cui è scritto.\\\\
$\phi_i$ è la \textbf{funzione calcolata dall'$i$-esimo algoritmo}. Per esempio da M$_i$ (con M Macchina di Turing).\\
$\phi_i$ è funzione, quindi semantica.\\
M$_i$ è algoritmo, quindi sintassi.\\
Può succedere che $\phi_i = \phi_j$ ma M$_i \neq$ M$_j$ (ad esempio \texttt{while(true) do skip} e \texttt{while(true) do skip;skip})

\section{•}
MdT $=_T$ \texttt{while} $=_T$ $\mu$-ricorsive\\
Grazie all'\textbf{enumerazione} di G\"{o}del, scrivo $\phi_i$ come la funzione calcolata dall'algoritmo $M_i$\\
D'ora in avanti parliamo solo di funzioni calcolabili, quindi $\phi_i$ \textit{è} calcolabile.\\
$\exists$? funzione calcolabile totale $t(i, n)$ che maggiora il tempo di calcolo di M$_i$(n)? No. Vediamo come dimostrarlo, introducendo una diagonalizzazione.\\
$t(i, n)$ = \begin{math}
\left\{
\begin{array}{c c}
	k & \textsl{se} M_i(n)\downarrow converge in meno di i passi\\
	0 & altrimenti
\end{array}
\right.
\end{math}\\
Sia T$_i$ la misura \textbf{esatta} del tempo di calcolo di M$_i$\\
T$_i$(n) $\leq$ $t(i, n)$ è calcolabile totale.\\
$T_x(x)$ tempo di calcolo effettivo, $t(x, x)$ tempo stimato\\
$\psi(x) = $
\begin{math}
\left\{
\begin{array}{c c}
	\phi_x(x) + 1 & T_x(x) \leq t(x, x)\\
	0 & altrimenti
\end{array}
\right.
\end{math}\\
Quindi $\psi$ è calcolabile totale.\\
Applico church-turing, quindi $\phi_i(i) = \psi(i) =$ \begin{math}
\left\{
\begin{array}{c c}
	\phi_i(i) + 1 & T_i(i) \leq t(i, i)\\
	0 & altrimenti
\end{array}
\right.
\end{math}\\
Ma siccome $\phi_i$ calcolabile totale, non può essere che quando termina sia $\phi_i(i) = \phi_i(i) + 1$, \textbf{assurdo}.\\Quindi $t(i, n)$ non è calcolabile totale, non c'è modo di stimare il tempo di calcolo.\\\\
Per lo stesso motivo non possiamo imporre limiti allo spazio.\\
$\exists$? funzione calcolabile totale che dato M$_i$, $x$ dice quante celle di memoria uno specifico calcolatore C userà per calcolare M$_i(x)$?\\
$h(i, x) = $\begin{math}
\left\{
\begin{array}{c c}
	1 & se M_i(x)\uparrow (su C)\\
	0 & altrimenti
\end{array}
\right.
\end{math}\\
Sia n la cardinalità di $\Sigma$ e m-1 cardinalità di Q e le celle di C sono $k$, posso scrivere $n^k$ stringhe diverse. Il cursore può stare su $k$ posizioni diverse e la macchina in $m$ stati diversi.\\
Il numero massimo di configurazioni (stato con posizione cursore e stringa su nastro) diverse è  $l = n^k \cdot k \cdot m$, con $n^k$ nastro scritto, $k$ è posizione del cursore e $m$ stati ($m - 1$ + $1$ per lo stato $h$ di halt)\\
Dopo $l$ passi la configurazione si ripete. Si può dire che la macchina è in ciclo. Quindi ho una contraddizione? Siccome la macchina attraversa un numero finito di config sup lim da $l$, se la macchina non si è arrestata prima di $l$ passi se ritrovo una config di prima la ritroverò, quindi non terminerà mai. Ho dimostrato che $h$ è calc tot, ma posso scrivere quindi $t$ della dim precedente, ma giungo all'assurdo. Quindi non posso mettere un limite al nastro.
\subsection{Teorema 1: Le Funzioni Calcolabili sono tante quante i numeri naturali}
Le $f$ calcolabili sono \#$N$. Anche le $f$ calcolabili totali sono \#$N$.\\
Esistono funzioni \textit{non} calcolabili, molte di più di quelle calcolabili.
\paragraph{Dimostrazione} Non sono più di \#$N$ perché posso calcolare le macchine di Turing. Almeno \#$N$ perché posso costruire una macchina che per qualsiasi input lascia un numero naturale sul nastro, quindi di queste ce ne sono almeno quanti sono i numeri naturali.
%TODO
\subsection{Teorema 2: Ogni funzione calcolabile $\phi_i$ ha infiniti indici}
Non solo, posso costruire A$_i$ tale che per ogni j in A$_i$ $\phi_j = \phi_i$ mediante una funzione ricorsiva primitiva\\
\paragraph{Dimostrazione} Sia $M_i$ un programma P. Prendo P;skip, poi P;skip;skip\ldots metto tanti ;skip quanti voglio. Posso generare un numero infinito di programmi che calcolano tutti la stessa funzione.
\subsection{Teorema 3: Forma Normale}
Prendendo algoritmo posso riscriverlo in una \textbf{forma canonica}/\textbf{normale}, che non è per forza migliore ma è una forma specifica.\\
$\exists$ predicato $T(i, x, y)$ e una funzione $U(y)$ ricorsive primitive tali che ogni funzione calcolabile $i$, $x$ $\phi_i(x)$ = $\mu$y.[$U(T(i, x, y))$]\\
\textbf{Corollario}: tutte le funzioni T-calcolabili sono anche $\mu$-calcolabili. Non solo, ma $\mu$y corrisponde al while, e T, U a due programmi \texttt{for}. Quindi ogni funzione calcolabile può essere ottenuta da due programmi scritti con il linguaggio \texttt{for} ed una sola applicazione del linguaggio \texttt{while}.
\paragraph{Dimostrazione} Devo costruire il predicato T e la funzione U.\\
%TODO
T come predicato di Kleane: T(i, x, y) vero sse y è la codifica di una computazione di M$_i$(x) terminante\\
Quando trovo tale y pongo U(y) = w. C'è un solo $y$ nelle macchine deterministiche, se c'è.
\subsection{Teorema 4: Teorema di enumerazione}
Esiste z tale che per ogni i, x $\phi_z(i, x) = \phi_i(x)$, z è MdT universale. z interprete, i è programma.\\
Fra tutti gli algoritmi che ne sono infiniti numerabili in gradi di eseguire tutti gli altri algoritmi.
\paragraph{Dimostrazione} $\phi_i(x) = \mu y.U(T(i, x, y)$ per th 3. Questo è algoritmo, avrà indice per church-turing, diciamo $\phi_z(i, x)$ senza y come argomento perché quantificata, non libera ma legata, \textit{variabile di lavoro}. Applico transitività dell'uguaglianza e ho finito  $\phi_i(x) = \phi_z(i, x)$.
\end{document}