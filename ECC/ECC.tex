\documentclass[10pt]{book}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{multicol}
\usepackage[bookmarks]{hyperref}
\usepackage[a4paper, total={18cm, 25cm}]{geometry}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{makecell}
\usepackage{mathrsfs}
\graphicspath{ {./img/} }
\usepackage{color}

\begin{document}
\renewcommand*\contentsname{Indice}
\title{Elementi di Calcolo e Complessità}
\author{Federico Matteoni}
\date{A.A. 2019/20}
\maketitle
\tableofcontents
\pagebreak
\section*{Introduzione}
Prof. Pierpaolo Degano \texttt{pierpaolo.degano@unipi.it}\\
Con Giulio Masetti \texttt{giulio.masetti@isti.snr.it}\\
Esame: compitini/scritto + orale
\pagebreak
\chapter{Calcolabilità}
\section{Teoria della Calcolabilità}
Illustra \textbf{cosa può essere calcolato da un computer} senza limitazioni di risorse come spazio, tempo ed energia. Vale a dire:
\begin{list}{-}{}
	\item Quali sono i \textbf{problemi \textit{solubili}} mediante una \textbf{procedura effettiva} (qualunque linguaggio su qualunque macchina)?
	\item Esistono \textbf{problemi \textit{insolubili}}? Sono interessanti, realistici, oppure puramente artificiali?
	\item Possiamo raggruppare i problemi in \textbf{classi}?
	\item Quali sono le \textbf{proprietà} delle classi dei problemi solubili?
	\item Quali sono le relazioni tra le classe dei problemi insolubili?
\end{list}
\paragraph{Astrazione} Utilizzeremo \textbf{termini astratti per descrivere la possibilità di eseguire un programma ed avere un risultato}. Questa astrazione è un \textbf{modello} che non tiene conto di dettagli al momento irrilevanti.\\
Un po' come l'equazione per dire quanto ci mette il gesso a cadere che non tiene conto delle forze di attrito dell'aria.
\paragraph{Problema della Decisione} Un problema è risolto se si conosce una \textbf{procedura} che permette di decidere con un numero \textbf{finito} di operazioni di decedere se una proposizione logica è vera o falsa.

\section{Algoritmo}
Un algoritmo è un insieme \textbf{finito} di istruzioni.
\paragraph{Istruzioni} Elementi da un insieme di \textbf{cardinalità finita} ed ognuna ha \textbf{effetto limitato} (localmente e "\textit{poco}") sui dati (che devono essere \textbf{discreti}). Un'istruzione deve richiedere tempo finito per essere elaborata.
\paragraph{Computazione} Successione di istruzioni finite in cui ogni passo dipende solo dai precedenti. Verificando una porzione finita dei dati (\textbf{deterministico}). Non c'è limite alla memoria necessaria al calcolo (è finita ma illimitata). Neanche il tempo è limitato (necessario al calcolo). Tanto tempo e tanta memoria quante ce ne servono.\\\\
Un'eccezione a questa definizione di algoritmo è costituita dalle macchine concorrenti/interattive, dove gli input variano nel tempo. Inoltre vi sono formalismi che tengono conto di algoritmi probabilistici e stocastici. Altre eccezioni sono gli algoritmi non deterministici, ma per ognuno di essi esiste un algoritmo deterministico equivalente (Teorema \texttt{3.3.6})
\pagebreak
\section{Macchina di Turing}
Introdotta da \textbf{Alan Turing} nel 1936, confuta la speranza "\textit{non ignorabimus}" di poter risolvere qualsiasi cosa con un programma.\\
Turing originariamente la presenta supponendo di aver un impiegato precisissimo ma stupido, con una pila di fogli di carta ed una penna, ed un foglio di carta con le istruzioni che esegue con estrema diligenza. Non capisce quello che fa, e si chiama "\textbf{computer}".

\paragraph{Struttura matematica} Una Macchina di Turing (MdT) è una quadrupla:
\begin{center}
M = (Q, $\sum$, $\delta$, q$_0$)
\end{center}
\begin{list}{}{}
	\item \textbf{Q} = \{q$_i$\} è l'insieme finito degli \textbf{stati} in cui si può trovare la macchina.\\
	Indicheremo con lo stato speciale \textit{h} la fine corretta della computazione, \textit{h} non $\in$ Q.
	\item $\sum$ = \{$\sigma$, $\sigma$'\ldots\} è l'insieme finito di \textbf{simboli}. 
	Ci sono elementi che devono per forza esistere:
	\begin{list}{}{}
		\item \textbf{\#} carattere \textbf{bianco}, vuoto
		\item $\triangleright$ carattere di inizio della memoria, chiamato \textbf{respingente}, che funziona come un inizio file
	\end{list}
	\item $\delta$ $\subseteq$ (Q $\times \sum$) $\rightarrow$ (Q' $\bigcup$ \{\textit{h}\}) $\times \sum$' $\times$ \{L, R, -\} è \textbf{funzione di transizione}.\\
	Mantiene determinismo perché funzione, ad un elemento associa un solo elemento (la transizione è univoca). Transizioni finite perché prodotto cartesiano di insiemi finiti.\\
$\delta$(q, $\triangleright$) = (q', $\triangleright$, R), cioè se sono a inizio file possono solo andare a destra.\\
Può essere vista come una relazione di transizione, $\delta \subseteq (Q \times \sum) \times (Q\:\bigcup\:\{\textit{h}\}) \times \sum \times \{L,\:R,\: -\}$
	\item q$_0 \in $ Q lo \textbf{stato iniziale} 
\end{list}
Mappatura a coda di rondine, bigezione tra (m, n) $\rightarrow$ k, cioè $N^2 \rightarrow N$.\\
Costruire un modello per il calcolo dopo aver posto delle condizioni affinché qualcosa si possa chiamare algoritmo.

\subsection{$\sum$}
\begin{list}{}{}
	\item $\sum^0$ = \{$\epsilon$\}, con $\epsilon =$ parola vuota, che non contiene caratteri
	\item $\sum^{i+1} = \sum \cdot \sum^i = \{\sigma \cdot u \:\:\vline\:\: \sigma \in \sum \:\wedge\: u \in \sum^i\}$
	\item $\sum^* = \bigcup_{i \in N}\sum^i$, insieme di tutte le possibili combinazioni di simboli
	\item $\sum^f = \sum^* \:\cdot\: (\sum \:-\: \{\#\} \:\bigcup\: \{\epsilon\})$, cioè linsieme di tutte le stringhe che terminano con un carattere non bianco ma può terminare con la stringa vuota
\end{list}
\paragraph{Esempio} $\sum_B = \{0, 1\} \longrightarrow \sum_B^* = \{\epsilon, 0, 1, 01, 10, 010, 110010, \ldots\}$ tutti i numeri binari

\subsection{Transizioni}
La \textbf{situazione corrente} di una macchina di Turing può essere scritto come $(q, u, \sigma, v)$ dove:
\begin{list}{}{}
	\item $q$ è lo \textbf{stato attuale}, $q \in Q$
	\item $u$ è la \textbf{stringa a sinistra} del carattere corrente, $u \in \sum^*$
	\item $\sigma$ è il \textbf{carattere corrente}, $\sigma \in \sum$
	\item $v$ è il \textbf{resto della stringa} che termina con un carattere non nullo, $v \in \sum^f$
\end{list}
Può anche essere più comodamente espressa come $(q, u \:\underline{\sigma}\: v)$

\subsection{Computazione}
Una computazione è una transizione $(q, x) \longrightarrow (q', \omega)$. Una macchina di Turing parte \textbf{sempre} da $(q_0, \underline{\triangleright} x)$.\\
Ogni computazione può esprimere il numero di passi necessari, ad esempio $\gamma \longrightarrow^n \gamma'$.\\
$\forall \:\:computazione\:\: \gamma \Rightarrow \gamma \longrightarrow^0 \gamma$. Inoltre se $\gamma \longrightarrow \gamma' \wedge \gamma' \longrightarrow^n \gamma''$ allora $\gamma \longrightarrow^{n+1} \gamma''$

\pagebreak

\paragraph{Esempio} Macchina di Turing che esegue la semplice somma di due semplici numeri romani.
\begin{multicols}{2}
\begin{center}
	\begin{tabular}{c | c | c}
		$q$ & $\sigma$ & $\delta(q, \sigma)$\\
		\hline
		$q_0$ & $\triangleright$ & $(q_0, \triangleright, R)$ \\
		$q_0$ & I & $(q_0, I, R)$ \\
		$q_0$ & $+$ & $(q_1, I, R)$ \\
		\hline
		$q_1$ & I & $(q_1, I, R)$ \\
		$q_1$ & \# & $(q_2, \#, L)$ \\
		\hline
		$q_2$ & I & $(h, \#, -)$ \\
	\end{tabular}
\end{center}
\columnbreak
$(q_0, \underline{\triangleright}II+III) \longrightarrow (q_0, \triangleright \underline{I}I+III) \longrightarrow (q_0, \triangleright I \underline{I}+III) \longrightarrow (q_0, \triangleright II \:\underline{+}\: III) \longrightarrow (q_1, \triangleright III\underline{I}II) \longrightarrow (q_1, \triangleright IIII \underline{I}I) \longrightarrow (q_1, \triangleright IIIII\underline{I}) \longrightarrow (q_1, \triangleright IIIIII\underline{\#}) \longrightarrow (q_2, \triangleright IIIII\underline{I}) \longrightarrow (h, \triangleright IIIII)$
\end{multicols}

\paragraph{Esempio} Macchina di Turing che verifica se una stringa di lettere $a, b$ è palindroma o no.
\begin{multicols}{2}
\begin{center}
	\begin{tabular}{c | c | c}
		$q$ & $\sigma$ & $\delta(q, \sigma)$\\
		\hline
		$q_0$ & $\triangleright$ & $(q_0, \triangleright, R)$ \\
		$q_0$ & $a$ & $(q_A, \triangleright, R)$ \\
		$q_0$ & $b$ & $(q_B, \triangleright, R)$ \\
		$q_0$ & $\#$ & $(h, \#, -)$ \\
		\hline
		$q_A$ & $a/b$ & $(q_A, a/b, R)$ \\
		$q_A$ & \# & $(q_{A'}, \#, L)$ \\
		\hline
		$q_{A'}$ & $a$ & $(q_R, \#, L)$ \\
		\hline
		$q_B$ & $a/b$ & $(q_B, a/b, R)$ \\
		$q_B$ & \# & $(q_{B'}, \#, L)$ \\
		\hline
		$q_{B'}$ & $a$ & $(q_R, \#, L)$ \\
		\hline
		$q_R$ & $a/b$ & $(q_R, a/b, R)$ \\
		$q_R$ & $\triangleright$ & $(q_0, \triangleright, R)$ \\
	\end{tabular}
\end{center}
\columnbreak
$(q_0, \underline{\triangleright}abba) \longrightarrow (q_0, \triangleright \underline{a}bba) \longrightarrow (q_A, \triangleright\triangleright \underline{b}ba) \longrightarrow \\ (q_A, \triangleright \triangleright b\underline{b}a) \longrightarrow (q_A, \triangleright \triangleright bb\underline{a}) \longrightarrow (q_A, \triangleright  \triangleright bba\underline{\#}) \longrightarrow \\ (q_{A'}, \triangleright \triangleright bb\underline{a}) \longrightarrow (q_R, \triangleright \triangleright b\underline{b}) \longrightarrow (q_R, \triangleright \triangleright \underline{b}b) \longrightarrow (q_R, \triangleright \underline{\triangleright} bb) \\ \longrightarrow (q_0, \triangleright \triangleright \underline{b}b) \longrightarrow (q_B, \triangleright \triangleright \triangleright \underline{b}) \longrightarrow (q_B, \triangleright \triangleright \triangleright b\underline{\#}) \longrightarrow \\ (q_{B'}, \triangleright \triangleright \triangleright \underline{b}) \longrightarrow (q_R, \triangleright \triangleright \underline{\triangleright})  \longrightarrow (h, \triangleright \triangleright \triangleright)$
\end{multicols}
\section{Linguaggi di Programmazione}
Un primo formalismo di algoritmo, come abbiamo visto, è la \textbf{macchina di Turing}: attenendosi alle richieste di tempo e spazio arbitrariamente grandi ma finiti, risolve un \textbf{problema}.\\
Un secondo formalismo sono i \textbf{linguaggi di programmazione}.
\subsection{Sintassi}
\paragraph{Sintassi astratta} Definiamo la \textbf{sintassi} dello scheletro di un semplice linguaggio di programmazione imperativo.\\
Una \textbf{sintassi astratta} è una sintassi non concreta, cioè che non tiene conto di alcune cose come la procedenza tra gli operatori.\\
\begin{list}{}{\textbf{Sintassi}}
	\item Expr $\rightarrow$ E ::= x $\vline\:$ n $\vline\:$ E + E $\vline\:$ E $\cdot$ E $\vline\:$ E - E
	\item Bexpr $\rightarrow$ B ::= tt $\vline\:$ ff $\vline\:$ E $<$ E $\vline\:$ $\neg$B $\vline\:$ B $\vee$ B
	\item Comm $\rightarrow$ C ::= skip $\vline\:$ x $=$ E $\vline\:$ C;C $\vline\:$ if B then C else C $\vline\:$ for i = E to E do C $\vline\:$ while B do C
\end{list}
\begin{list}{}{Abbiamo una serie di insiemi da definire ulteriormente}
	\item x $\in$ Var, l'insieme delle \textbf{variabili}
	\item n $\in$ $N$, \textbf{numeri naturali}.
\end{list}
\begin{list}{}{Abbiamo anche la \textbf{memoria} per poter \textbf{assegnare ad una variabile il suo significato}}
	\item $\sigma$ : Var $\rightarrow_{fin} N$\\
	Si dice "a dominio finito", indicata dal $fin$ sotto la freccia, per indicare che il dominio Var ha cardinalità finita. Var dominio è quindi un sottoinsieme di Var insieme delle variabili che sarebbe infinito.\\
	La memoria si può aggiornare, diventando $\sigma'$ = $\sigma[$x$\:\mapsto\:$n$]$.\\Ad esempio, $\sigma'(y)$ = n se y = x, altrimenti $\sigma'(y)$ = $\sigma(y)$
\end{list}
\pagebreak
\subsection{Funzioni di Valutazione}
\begin{list}{}{Inoltre, per valutare le espressioni generate dalla grammatica, servono delle \textbf{funzioni di valutazione}. Esse \textbf{trovano il significato di ogni espressione}}
	\item Funzione di valutazione delle espressioni\\$\mathscr{E}$ : Expr $\times$ (Var $\rightarrow N$) $\rightarrow N$\\La sua \textbf{semantica denotazionale} è la seguente
	\begin{multicols}{2}
	\begin{list}{}{}
		\item $\mathscr{E}[$x$]_\sigma$ = $\sigma$(x)
		\item $\mathscr{E}[$n$]_\sigma$ = n
		\item $\mathscr{E}[$E$_1$ $\pm$ E$_2]_\sigma$ = $\mathscr{E}[$E$_1]_\sigma$ $\pm$ $\mathscr{E}[$E$_2]_\sigma$
	\end{list}
	\end{multicols}
	Importante notare come gli operatori $+$, $-$, $\cdot$ \textit{dentro} le espressioni siano dei \textbf{semplici token denotazionali}, mentre sono gli operatori \textit{valutati} ad eseguire il vero e proprio calcolo. Per chiarire questo aspetto, facciamo un esempio. Valutiamo con la nostra funzione $\mathscr{E}[$E$_1$ $+$ E$_2]_\sigma$ = $\mathscr{E}[$E$_1]_\sigma$ \textit{più} $\mathscr{E}[$E$_2]_\sigma$. Se non definiamo l'operatore "\textit{più}", allora se poniamo $\sigma$(x) = 25 la valutazione
	\begin{list}{}{}
		\item $\mathscr{E}[$3 + x$]_\sigma$ = $\mathscr{E}[$3$]_\sigma$ \textit{più} $\mathscr{E}[$x$]_\sigma$ = 3 \textit{più} 25 = 42
	\end{list}
	è corretta quanto
	\begin{list}{}{}
		\item $\mathscr{E}[$3 + x$]_\sigma$ = $\mathscr{E}[$3$]_\sigma$ \textit{più} $\mathscr{E}[$x$]_\sigma$ = 3 \textit{più} 25 = 28
	\end{list}
	Ovviamente utilizzeremo la valutazione specificata in precedenza e gli operatori aritmetici assumeranno il loro significato standard.\\
	L'unica eccezione è l'operatore $-$, che nel nostro caso sarà il \textbf{meno limitato} dal simbolo $\dot{-}$, la cui unica differenza è che non può dare un risultato inferiore a 0. Ad esempio, 5 $\dot{-}$ 7 = 0
	\item Funzione di valutazione di espressioni booleane\\$\mathscr{B}$ : Bexpr $\times$ (Var $\rightarrow N$) $\rightarrow$ \{tt, ff\}\\
	La cui \textbf{semantica denotazionale} è la seguente
	\begin{multicols}{2}
	\begin{list}{}{}
		\item $\mathscr{B}[$tt$]_\sigma$ = tt
		\item $\mathscr{B}[$ff$]_\sigma$ = ff
		\item $\mathscr{B}[$E$_1 <$ E$_2]_\sigma$ = $\mathscr{E}[$E$_1]_\sigma$ $<$ $\mathscr{E}[$E$_2]_\sigma$
		\item $\mathscr{B}[\neg$B$]_\sigma$ = $\neg\mathscr{B}[$B$]_\sigma$
		\item $\mathscr{B}[$B$_1 \vee$ B$_2]_\sigma$ = $\mathscr{B}[$B$_1]_\sigma$ $\vee$ $\mathscr{B}[$B$_2]_\sigma$
	\end{list}
	\end{multicols}
	Anche qua vale il medesimo discorso sulla definizione sugli effettivi operatori.
\end{list}
\subsection{Semantica Operazione Strutturale}
\paragraph{Structural Operationale Semantics} Metodo attraverso il quale viene fornita la semantica dei comandi. Parte da un \textbf{insieme di configurazioni $\Gamma$}
\begin{list}{}{}
	\item $\Gamma$ = \{(C, $\sigma$) $\vline\:$ FV(C) $\subset$ dom($\sigma$)\} $\cup$ \{$\sigma$\}
\end{list}
dove FV(C) sono le \textbf{variabili del programma} e con FV(C) $\subset$ dom($\sigma$) si richiede che tutte le variabili del programma abbiano un valore nella memoria fornita. Si fa l'unione con la sola memoria $\sigma$ perché la situazione finale è (  , $\sigma$) che, analogamente allo stato fittizio $h$ nella macchina di Turing, segnala la fine dell'esecuzione. Inoltre si hanno le \textbf{transizioni $\rightarrow$}
\begin{list}{}{}
	\item $\rightarrow \:\subset \Gamma \times \Gamma$
\end{list}
Definiamo quindi un \textbf{insieme di transizioni ($\Gamma$, $\rightarrow$)} tramite delle \textbf{regole di inferenza} del tipo $\frac{premesse}{conclusione}$. In assenza di premesse, $-$, la regola di inferenza si dice \textbf{assioma}.
\begin{multicols}{2}
	$$\frac{-}{(skip, \sigma) \rightarrow \sigma}$$
	$$\frac{-}{(x = E, \sigma) \rightarrow \sigma[x\:\mapsto\:n]}\mathscr{E}[E]_\sigma = n$$
	$$\frac{(C_1, \sigma) \rightarrow (C_1', \sigma')}{(C_1;C_2, \sigma) \rightarrow (C_1';C_2, \sigma')}$$
	$$\frac{-}{(if\:\: B\:\: then\:\: C_1\:\: else\:\: C_2, \sigma) \rightarrow(C_1, \sigma)}\mathscr{B}[B]_\sigma = tt$$
	$$\frac{-}{(if\:\: B\:\: then\:\: C_1\:\: else\:\: C_2, \sigma) \rightarrow(C_2, \sigma)}\mathscr{B}[B]_\sigma = ff$$
	$$\frac{-}{(for\:\: i = E_1\:\: to\:\: E_2\:\: do\:\: C, \sigma) \rightarrow \sigma}\mathscr{B}[E_2 < E_1]_\sigma = tt$$
\end{multicols}
	$$\frac{-}{(for\:\: i = E_1\:\: to\:\: E_2\:\: do\:\: C, \sigma) \rightarrow (i = n_1;\:\:C;\:\:for\:\: i = n_1 + 1\:\:to\:\:n_2\:\:do\:\:C, \sigma)}\mathscr{B}[E_2 < E_1]_\sigma = ff\: \wedge\: \mathscr[E_1]_\sigma = n_1 \wedge\: \mathscr[E_2]_\sigma = n_2$$
	$$\frac{-}{(while\:\:B\:\:do\:\:C, \sigma) \rightarrow (if\:\:B\:\:then\:\:C;\:\:while\:\:B\:\:do\:\:C,\sigma)} $$
\section{Calcolabilità}
\subsection{T-Calcolabile}
Dati $\Sigma$ alfabeto della macchina, $\Sigma_0$ alfabeto di input e $\Sigma_1$ alfabeto di output, con \#, $\triangleright \not\in \Sigma_0 \cup \Sigma_1 \subset \Sigma$
\begin{center}
M=(Q, $\Sigma$, $\delta$, q$_0$) calcola $f$ : $\Sigma_0^* \longrightarrow \Sigma_1^*$ $\Leftrightarrow$ ($\forall w \in \Sigma_0^* \wedge f(w) = x \Rightarrow M(w) \rightarrow_{fin}$ (h, $\triangleright$z)$)$
\end{center}
Si dice che la \textbf{funzione} $f$ è \textbf{T-Calcolabile}.\\
Cioè, esiste una macchina di Turing che per ogni stringa finita in input arriva, con un numero finito di passi, all'arresto lasciando sul nastro la stringa di output corretta. Notare come non viene data nessuna interpretazione al risultato della $f$.
\subsection{\texttt{while}-Calcolabile}
\begin{center}
C calcola $f$ : Var $\rightarrow$ $N$ $\Leftrightarrow$ ($\forall\:\: \sigma$ : Var $\rightarrow$ $N$ $\wedge$ $f(x) = n$ $\Rightarrow$ C($\sigma$) $\rightarrow_{fin}$ $\sigma'$ $\wedge$ $\sigma'(x) = n$)
\end{center}
Si dice che la funzione $f$ è \textbf{\texttt{while}-Calcolabile}.\\
Cioè esiste un programma C che calcola il risultato corretto in un numero finito di passi.
\paragraph{Invariante} Tutti i risultati visti fin'ora \textbf{sono invarianti rispetto al modello dei dati}, e questo vale anche per la T-Calcolabilità e la \texttt{while}-Calcolabilità.\\
In particolare, se ho i dati in un formato A allora posso codificarli nel formato B in cui opera la macchina, calcolare il risultato in formato B e decoficarlo nel formato A di partenza. Questo vale se \textbf{le codifiche sono funzioni biunivoche e "\textit{facili}"}. Vedremo cosa significa essere "facili", ma per adesso basti pensare ad un numero finito di passi e che terminano sempre.
\subsection{Esempio di codifica}
\begin{multicols}{2}
\begin{center}
	\begin{tabular}{c || c | c | c | c | c | c}
	 & 0 & 1 & 2 & 3 & 4 & 5 \\
	 \hline
	 \hline
	 0 & 0 & 2 & 5 & 9 & 14 & \\
	 \hline
	 1 & 1 & 4 & 8 & 13 & & \\
	 \hline
	 2 & 3 & 7 & 12 & & & \\
	 \hline
	 3 & 6 & 11 & \ldots & & & \\
	 \hline
	 4 & 10 & 16 & & & & \\
	 \hline
	 5 & 15 & & & & & 
	\end{tabular}\\
	Codifica a coda di rondine
\end{center}
\columnbreak
\paragraph{Codifica} ($x$, $y$) $\mapsto$ $\frac{1}{2}$($x^2 + 2xy + y^2 + 3x + y$)\\
Es. (3, 1) $\mapsto$ $\frac{1}{2}$($9 + 6 + 1 + 9 + 1$) = $\frac{26}{2}$ = 13
\paragraph{Decodifica} $n$ $\mapsto$ ($n - \frac{1}{2}k(k + 1)$, $k - (n - \frac{1}{2}k(k+1))$) con $k = \lfloor\frac{1}{2}(\sqrt{1 + 8n} -1)\rfloor$\\\\
Es 8 $\mapsto$ ($8 - 6$, $6 - 8 + 3$) = ($2$, $1$)\\
$k = \lfloor\frac{1}{2}\sqrt{1 + 8\cdot 8} - 1\rfloor = 3$\\
$\frac{k(k+1)}{2} = 6$
\end{multicols}
\pagebreak
\section{Notazione}
Una \textbf{funzione} $f$ è $\subset$ A $\times$ B, con A spazio di partenza e B codominio. Quindi $f$(a) = b si può esprimere anche con (a, b) $\in$ $f$, con a $\in$ A e b $\in$ B.
\begin{list}{}{}
	\item $f$(a) = b $\wedge$ $f$(a) = c $\Rightarrow$ b = c
	\item Considereremo \textbf{funzioni parziali}, cioè funzioni con A contenente punti dove $f$ non è definita. Non è quindi detto che $\forall$ a $\in$ A $\exists$ b $\in$ B \vline $\:\:f$(a) = b
	\item $f$ \textbf{converge} su a, cioè $f$(a)$\downarrow$ $\Leftrightarrow$ $\exists$ b $\vline\:$ $f$(a) = b
	\item $f$ \textbf{diverge} su a, cioè $f$(a)$\uparrow$ $\Leftrightarrow$ $\not\exists$ b $\vline\:$ $f$(a) = b
	\item \textbf{Dominio} di $f$: $dom(f)$ = \{a \vline$\:\: f$(a)$\downarrow$\}
	\item \textbf{Immagine} di $f$: $imm(f)$ = \{b \vline$\:\: \exists$ a $\in$ A $\Rightarrow$ $f$(a) = b\}
\end{list}
\paragraph{Rapporto tra algoritmi A e funzioni $f$} $f$ è un \textbf{insieme potenzialmente infinito di coppie}, ma non posso assegnare due $f$ diverse allo stesso insieme, mentre esistono tanti algoritmi diversi che calcolano la stessa funzione.\\
Ad esempio, $f$ = $\emptyset$ è calcolata da \texttt{while(true) do skip} ma anche da \texttt{while(true) do skip;skip}.
\begin{enumerate}
	\item Quali sono le funzioni calcolabili?\\
	Nelle ipotesi iniziali di definizione di algoritmo, per adesso conosciamo le T-Calcolabili e le \texttt{while}-Calcolabili.
	\item Quali proprietà hanno?\\
	Posso combinarle?
	\item Esistono funzioni non calcolabili?
	\item Sono interessanti?\\
	Esistono a prescindere dalla macchina?
\end{enumerate}
\paragraph{Algoritmi e calcolabilità} Per ora abbiamo definito gli algoritmi in base al loro comportamento, sotto forma di \textbf{configurazioni che si susseguono} del tipo (istr. corrente + \ldots, memoria). Abbiamo anche diversi modi di affrontare la calcolabilità:
\begin{enumerate}
	\item \textbf{Hardware}, con la macchina di Turing\\
	Questo è uno dei primi esempio di calcolo, è semplice da capire e si descrivono direttamente macchina che eseguono gli algoritmi. Uno dei primi approcci allo studio della complessità.\\
	\textbf{Cambio programma $\rightarrow$ Cambio macchina}
	\item \textbf{Software}\\
	Ho l'interprete, cioè la semantica, fissi. Se cambio il programma non devo cambiare la macchina
	\begin{enumerate}
		\item Programmi \texttt{while}\\
		Base della programmazione iterativa, dalla semantica operazionale e anch'essi usati per lo studio della complessità
		\item Funzioni ricorsive\\
		Base della programmazione funzionale
	\end{enumerate}
\end{enumerate}
\pagebreak
\section{Ricorsive primitive}
$$\lambda x.e$$
$x$ è variabile (legata), $e$ è espressione\\
Es: $\lambda y. x + y$, $\lambda x \lambda y.x + y$\\
Useremo questa espressione per indicare le variabili che appaiono.\\
Al posto di $\lambda x_1, x_2,\ldots, x_n$ scriverò $\lambda \overrightarrow{x}$\\\\
\subsection{Funzione ricorsiva}
Classe C delle funzioni ricorsive primitive è la \textbf{minima classe} di funzioni che obbediscono alle seguenti regole di inferenza, regole di sintassi per definire le funzioni.
\begin{list}{}{\textbf{Casi base}}
	\item \textbf{Zero}: $\lambda \overrightarrow{x}.0$\\
	Prende un vettore di argomenti e restituisce 0.
	\item \textbf{Successore}: $\lambda x.x+1$\\
	Prende un valore e restituisce il suo successore.
	\item \textbf{Proiezione}/\textbf{Identità}: $\lambda \overrightarrow{x}.x_i$\\
	$\overrightarrow{x} = x_1,\ldots, x_n$, $1 \leq i \leq n$
\end{list}
\begin{list}{}{\textbf{Casi iterativi}}
	\item \textbf{Composizione}\\
	Se $g_1,\ldots, g_n \in C$ con $k$ argomenti ("a $k$ posti")\\
	e $h \in C$ a $n$ posti\\
	$\Rightarrow \lambda x_1, \ldots, x_n.h(g_1(\overrightarrow{x},\ldots, g_n(\overrightarrow{x})) \in C$
	\item \textbf{Ricorsione primitiva}\\
	Se $h \in C$ a $n + 1$ posti\\
	e $g \in C$ a $n - 1$ posti\\
	$\Rightarrow f(0, x_2, \ldots, x_n) = g(x_2, \ldots, x_n)$\\
	$f(x_1 + 1, x_2, \ldots, x_n) = h(x_1, f(x_1, x_2, \ldots, x_n), x_2,\ldots, x_n)$
\end{list}
$f \in C \Leftrightarrow$ esiste una successione $f_0, \ldots f_n = f\:\:\vline\:\:\forall f_1$ è ottenuto con i casi base oppure $f_i$ è ottenuto con i casi iterativi da $f_j$ con $j < i$
\paragraph{Esempio} Esempio di funzioni ricorsive\\
$f_1 = \lambda x.x$\\
$f_2 = \lambda x.x+1$\\
$f_3 = \lambda x_1, x_2, x_3. x_2$\\
$f_4 = f_2(f_3(x_1, x_2, x_3))$\\
$| f_5(0, x_2) = f_1(x_2)$\\
$| f_5(x_1 + 1, x_2) = f_4(x_1, f_5(x_1, x_2), x_2)$\\\\
Proviamo a calcolare $f_5(2, 3) =$ %TODO sistemare
$$= f_5(1 + 1, 3) = f_4(1, \underline{f_5(1, 3)}, 3) = f_4(1, \underline{f_4(0, f_5(0, 3), 3)}, 3) = f_4(1, f_4(0, f_1(3), 3), 3) = $$
$$ = f_4(1, f_4(0, 3, 3), 3) = f_4(1, f_2(f_3(0, 3, 3)), 3) = f_4(1, f_2(3), 3) = f_4(1, 4, 3) = f_2(f_3(1, 4, 3) = $$
$$ = f_2(4) = 5$$
\textbf{Regola di valutazione interna-sinistra}: valuto per primo quello che sta dentro i parametri partendo da sinistra.\\
Vediamo cosa succede con una regola di valutazione esterna:
$$f_5(2, 3) = f_4( 1, f_5(1, 3), 3) = f_2(f_3(1, f_5(1, 3), 3)) = f_3(1, f_5(1, 3), 3) + 1 = \underline{f_5(1, 3)} + 1 = f_4(0, f_5(0, 3), 3) + 1 =$$
$$= f_2(f_3(0, f_5(0, 3), 3) + 1 =  $$ %TODO p. 32 dispense
\subsubsection{Meno Limitato}
$f_7(x, y) = y$\\
$f_8(x, y) = x$\\
$| pred(0) = 0$\\
$| pred(x + 1) = f_8(x, pred(x))$\\
$f_9(x, y, z) = pred(f_3(x, y, z)$\\
$| f_{10}(0, y) = f_1(y)$\\
$| f_{10}(x + 1, y) = f_9(x, f_{10}(x, y), y)$\\
$\Rightarrow x \dot{-} y = f_{10}(f_7(x, y), f_8(x, y))$
\subsubsection{Somma}
Non è altro che generalizzazione del successore, applico il successore tante volte quante servono.\\
$| 0 + y = y$\\
$| (x + 1) + y = (x + y) + 1$
\subsubsection{Prodotto}
Sfrutto la somma\\
$| 0 * y = 0$\\
$| (x + 1) * y = (x * y) + y)$
\subsubsection{Potenza}
Generalizza il prodotto\\
$| x^0 = 1$\\
$| x^{y + 1} = (x^y) * x$\\
C'è un modo per generalizzare la potenza? $\Rightarrow$ \textbf{Ackerman}.
\subsection{Relazione}
$\chi_R(x_1,\ldots, x_n) = 1 se (x_1, \ldots, x_n) \in R, 0 se \not\in$\\
Quindi se $\chi_R$ è ricorsiva primitiva allora anche $R$ è ricorsiva primitiva.\\\\
$\chi$\\ %TODO
$P =$ \{ $n$ è primo\} è ricorsiva primitiva cioè la sua funzione caratteristica è ricorsiva primitiva. Questo per il teorema di fattorizzazione unica.\\
$\forall x \in N\:\:\exists$ numero finito di esponenti $x_1 \neq 0\:\:\vline\:\: x = p_0^{x_1}\cdot p_1^{x_1}\cdot\ldots\cdot p_n^{x_n}$\\
Come trovare tali esponenti con $f$ ricorsiva primitiva.\\
M = (Q, $\Sigma$, $\delta$, q$_0$)\\
Q = \{q$_0$, \ldots, q$_k$), $\Sigma$ = \{$\sigma_0$, \ldots, $\sigma_n$)\\
%TODO quintuple
\textbf{Kurt Godel}: rappresentare algoritmi come numeri\\\\
\subsection{Funzione di Ackermann}
$$A(0, 0, y) = y$$
$$A(0, x + 1, y) = A(0, x, y) + 1$$
$$A(1, 0, y) = 0$$
$$A(z + 2, 0, y) = 1$$
$$A(z + 1, x + 1, y) = A(z, A(z + 1, x, y), y)\:\:\:\:\textbf{doppia ricorsione}$$
Cresce più rapidamente di ogni funzione ricorsiva primitiva.
\begin{list}{}{}
	\item $A(0, x, y) = y + x$
	\item $A(1, x, y) = y * x$
	\item $A(2, x, y) = y^x$
	\item $A(3, x, y) = y^{y^{\ldots^y}}$ per $x$ volte
\end{list}

\end{document}