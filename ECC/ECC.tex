\documentclass[10pt]{book}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{multicol}
\usepackage[bookmarks]{hyperref}
\usepackage[a4paper, total={18cm, 25cm}]{geometry}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{makecell}
\graphicspath{ {./img/} }
\usepackage{color}

\begin{document}
\renewcommand*\contentsname{Indice}
\title{Elementi di Calcolo e Complessità}
\author{Federico Matteoni}
\date{A.A. 2019/20}
\maketitle
\tableofcontents
\pagebreak
\section*{Introduzione}
Prof. Pierpaolo Degano \texttt{pierpaolo.degano@unipi.it}\\
Con Giulio Masetti \texttt{giulio.masetti@isti.snr.it}\\
Esame: compitini/scritto + orale
\pagebreak
\chapter{Calcolabilità}
\section{Teoria della Calcolabilità}
Illustra \textbf{cosa può essere calcolato da un computer} senza limitazioni di risorse come spazio, tempo ed energia. Vale a dire:
\begin{list}{-}{}
	\item Quali sono i \textbf{problemi \textit{solubili}} mediante una \textbf{procedura effettiva} (qualunque linguaggio su qualunque macchina)?
	\item Esistono \textbf{problemi \textit{insolubili}}? Sono interessanti, realistici, oppure puramente artificiali?
	\item Possiamo raggruppare i problemi in \textbf{classi}?
	\item Quali sono le \textbf{proprietà} delle classi dei problemi solubili?
	\item Quali sono le relazioni tra le classe dei problemi insolubili?
\end{list}
\paragraph{Astrazione} Utilizzeremo \textbf{termini astratti per descrivere la possibilità di eseguire un programma ed avere un risultato}. Questa astrazione è un \textbf{modello} che non tiene conto di dettagli al momento irrilevanti.\\
Un po' come l'equazione per dire quanto ci mette il gesso a cadere che non tiene conto delle forze di attrito dell'aria.
\paragraph{Problema della Decisione} Un problema è risolto se si conosce una \textbf{procedura} che permette di decidere con un numero \textbf{finito} di operazioni di decedere se una proposizione logica è vera o falsa.

\section{Algoritmo}
Un algoritmo è un insieme \textbf{finito} di istruzioni.
\paragraph{Istruzioni} Elementi da un insieme di \textbf{cardinalità finita} ed ognuna ha \textbf{effetto limitato} (localmente e "\textit{poco}") sui dati (che devono essere \textbf{discreti}). Un'istruzione deve richiedere tempo finito per essere elaborata.
\paragraph{Computazione} Successione di istruzioni finite in cui ogni passo dipende solo dai precedenti. Verificando una porzione finita dei dati (\textbf{deterministico}). Non c'è limite alla memoria necessaria al calcolo (è finita ma illimitata). Neanche il tempo è limitato (necessario al calcolo). Tanto tempo e tanta memoria quante ce ne servono.\\\\
Un'eccezione a questa definizione di algoritmo è costituita dalle macchine concorrenti/interattive, dove gli input variano nel tempo. Inoltre vi sono formalismi che tengono conto di algoritmi probabilistici e stocastici. Altre eccezioni sono gli algoritmi non deterministici, ma per ognuno di essi esiste un algoritmo deterministico equivalente (Teorema \texttt{3.3.6})
\pagebreak
\section{Macchina di Turing}
Introdotta da \textbf{Alan Turing} nel 1936, confuta la speranza "\textit{non ignorabimus}" di poter risolvere qualsiasi cosa con un programma.\\
Turing originariamente la presenta supponendo di aver un impiegato precisissimo ma stupido, con una pila di fogli di carta ed una penna, ed un foglio di carta con le istruzioni che esegue con estrema diligenza. Non capisce quello che fa, e si chiama "\textbf{computer}".

\paragraph{Struttura matematica} Una Macchina di Turing (MdT) è una quadrupla:
\begin{center}
M = (Q, $\sum$, $\delta$, q$_0$)
\end{center}
\begin{list}{}{}
	\item \textbf{Q} = \{q$_i$\} è l'insieme finito degli \textbf{stati} in cui si può trovare la macchina.\\
	Indicheremo con lo stato speciale \textit{h} la fine corretta della computazione, \textit{h} non $\in$ Q.
	\item $\sum$ = \{$\sigma$, $\sigma$'\ldots\} è l'insieme finito di \textbf{simboli}. 
	Ci sono elementi che devono per forza esistere:
	\begin{list}{}{}
		\item \textbf{\#} carattere \textbf{bianco}, vuoto
		\item $\triangleright$ carattere di inizio della memoria, chiamato \textbf{respingente}, che funziona come un inizio file
	\end{list}
	\item $\delta$ $\subseteq$ (Q $\times \sum$) $\rightarrow$ (Q' $\bigcup$ \{\textit{h}\}) $\times \sum$' $\times$ \{L, R, -\} è \textbf{funzione di transizione}.\\
	Mantiene determinismo perché funzione, ad un elemento associa un solo elemento (la transizione è univoca). Transizioni finite perché prodotto cartesiano di insiemi finiti.\\
$\delta$(q, $\triangleright$) = (q', $\triangleright$, R), cioè se sono a inizio file possono solo andare a destra.\\
Può essere vista come una relazione di transizione, $\delta \subseteq (Q \times \sum) \times (Q\:\bigcup\:\{\textit{h}\}) \times \sum \times \{L,\:R,\: -\}$
	\item q$_0 \in $ Q lo \textbf{stato iniziale} 
\end{list}
Mappatura a coda di rondine, bigezione tra (m, n) $\rightarrow$ k, cioè $N^2 \rightarrow N$.\\
Costruire un modello per il calcolo dopo aver posto delle condizioni affinché qualcosa si possa chiamare algoritmo.

\subsection{$\sum$}
\begin{list}{}{}
	\item $\sum^0$ = \{$\epsilon$\}, con $\epsilon =$ parola vuota, che non contiene caratteri
	\item $\sum^{i+1} = \sum \cdot \sum^i = \{\sigma \cdot u \:\:\vline\:\: \sigma \in \sum \:\wedge\: u \in \sum^i\}$
	\item $\sum^* = \bigcup_{i \in N}\sum^i$, insieme di tutte le possibili combinazioni di simboli
	\item $\sum^f = \sum^* \:\cdot\: (\sum \:-\: \{\#\} \:\bigcup\: \{\epsilon\})$, cioè linsieme di tutte le stringhe che terminano con un carattere non bianco ma può terminare con la stringa vuota
\end{list}
\paragraph{Esempio} $\sum_B = \{0, 1\} \longrightarrow \sum_B^* = \{\epsilon, 0, 1, 01, 10, 010, 110010, \ldots\}$ tutti i numeri binari

\subsection{Transizioni}
La \textbf{situazione corrente} di una macchina di Turing può essere scritto come $(q, u, \sigma, v)$ dove:
\begin{list}{}{}
	\item $q$ è lo \textbf{stato attuale}, $q \in Q$
	\item $u$ è la \textbf{stringa a sinistra} del carattere corrente, $u \in \sum^*$
	\item $\sigma$ è il \textbf{carattere corrente}, $\sigma \in \sum$
	\item $v$ è il \textbf{resto della stringa} che termina con un carattere non nullo, $v \in \sum^f$
\end{list}
Può anche essere più comodamente espressa come $(q, u \:\underline{\sigma}\: v)$

\subsection{Computazione}
Una computazione è una transizione $(q, x) \longrightarrow (q', \omega)$. Una macchina di Turing parte \textbf{sempre} da $(q_0, \underline{\triangleright} x)$.\\
Ogni computazione può esprimere il numero di passi necessari, ad esempio $\gamma \longrightarrow^n \gamma'$.\\
$\forall \:\:computazione\:\: \gamma \Rightarrow \gamma \longrightarrow^0 \gamma$. Inoltre se $\gamma \longrightarrow \gamma' \wedge \gamma' \longrightarrow^n \gamma''$ allora $\gamma \longrightarrow^{n+1} \gamma''$

\pagebreak

\paragraph{Esempio} Macchina di Turing che esegue la semplice somma di due semplici numeri romani.
\begin{multicols}{2}
\begin{center}
	\begin{tabular}{c | c | c}
		$q$ & $\sigma$ & $\delta(q, \sigma)$\\
		\hline
		$q_0$ & $\triangleright$ & $(q_0, \triangleright, R)$ \\
		$q_0$ & I & $(q_0, I, R)$ \\
		$q_0$ & $+$ & $(q_1, I, R)$ \\
		\hline
		$q_1$ & I & $(q_1, I, R)$ \\
		$q_1$ & \# & $(q_2, \#, L)$ \\
		\hline
		$q_2$ & I & $(h, \#, -)$ \\
	\end{tabular}
\end{center}
\columnbreak
$(q_0, \underline{\triangleright}II+III) \longrightarrow (q_0, \triangleright \underline{I}I+III) \longrightarrow (q_0, \triangleright I \underline{I}+III) \longrightarrow (q_0, \triangleright II \:\underline{+}\: III) \longrightarrow (q_1, \triangleright III\underline{I}II) \longrightarrow (q_1, \triangleright IIII \underline{I}I) \longrightarrow (q_1, \triangleright IIIII\underline{I}) \longrightarrow (q_1, \triangleright IIIIII\underline{\#}) \longrightarrow (q_2, \triangleright IIIII\underline{I}) \longrightarrow (h, \triangleright IIIII)$
\end{multicols}

\paragraph{Esempio} Macchina di Turing che verifica se una stringa di lettere $a, b$ è palindroma o no.
\begin{multicols}{2}
\begin{center}
	\begin{tabular}{c | c | c}
		$q$ & $\sigma$ & $\delta(q, \sigma)$\\
		\hline
		$q_0$ & $\triangleright$ & $(q_0, \triangleright, R)$ \\
		$q_0$ & $a$ & $(q_A, \triangleright, R)$ \\
		$q_0$ & $b$ & $(q_B, \triangleright, R)$ \\
		$q_0$ & $\#$ & $(h, \#, -)$ \\
		\hline
		$q_A$ & $a/b$ & $(q_A, a/b, R)$ \\
		$q_A$ & \# & $(q_{A'}, \#, L)$ \\
		\hline
		$q_{A'}$ & $a$ & $(q_R, \#, L)$ \\
		\hline
		$q_B$ & $a/b$ & $(q_B, a/b, R)$ \\
		$q_B$ & \# & $(q_{B'}, \#, L)$ \\
		\hline
		$q_{B'}$ & $a$ & $(q_R, \#, L)$ \\
		\hline
		$q_R$ & $a/b$ & $(q_R, a/b, R)$ \\
		$q_R$ & $\triangleright$ & $(q_0, \triangleright, R)$ \\
	\end{tabular}
\end{center}
\columnbreak
$(q_0, \underline{\triangleright}abba) \longrightarrow (q_0, \triangleright \underline{a}bba) \longrightarrow (q_A, \triangleright\triangleright \underline{b}ba) \longrightarrow \\ (q_A, \triangleright \triangleright b\underline{b}a) \longrightarrow (q_A, \triangleright \triangleright bb\underline{a}) \longrightarrow (q_A, \triangleright  \triangleright bba\underline{\#}) \longrightarrow \\ (q_{A'}, \triangleright \triangleright bb\underline{a}) \longrightarrow (q_R, \triangleright \triangleright b\underline{b}) \longrightarrow (q_R, \triangleright \triangleright \underline{b}b) \longrightarrow (q_R, \triangleright \underline{\triangleright} bb) \\ \longrightarrow (q_0, \triangleright \triangleright \underline{b}b) \longrightarrow (q_B, \triangleright \triangleright \triangleright \underline{b}) \longrightarrow (q_B, \triangleright \triangleright \triangleright b\underline{\#}) \longrightarrow \\ (q_{B'}, \triangleright \triangleright \triangleright \underline{b}) \longrightarrow (q_R, \triangleright \triangleright \underline{\triangleright})  \longrightarrow (h, \triangleright \triangleright \triangleright)$
\end{multicols}

\end{document}