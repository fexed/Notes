\documentclass[10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{multicol}
\usepackage[a4paper, total={18cm, 25cm}]{geometry}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{makecell}
\graphicspath{ {./img/} }
\usepackage{color}

\begin{document}
\title{Laboratorio di Reti}
\author{Federico Matteoni}
\date{ }
\renewcommand*\contentsname{Indice}

\maketitle
\section{Thread}
\paragraph{Processo} Istanza di un programma in esecuzione
\paragraph{Thread} \textbf{Flusso di esecuzione} all'interno di un processo $\Rightarrow$ Ogni processo ha almeno un thread.\\I \textbf{thread condividono le risorse di un processo}.\\
Possono essere eseguiti sia su single-core (es. interleaving, time-sharing\ldots) che su multicore (più flussi di esecuzione in parallelo)
\paragraph{Multitasking} \begin{list}{}{Si può riferire a}
	\item Processi, controllato esclusivamente dal S.O.
	\item Thread, controllato in parte dal programmatore
\end{list}
\paragraph{Contesto di un processo} Insieme delle informazioni necessarie per ristabilire esattamente lo stato in cui si trova il S.O. nel momento in cui si interrompe l'esecuzione di un processo per passare ad un altro: registri del processore, memoria del processo\ldots
\paragraph{Perché?} Per gestire più funzionalità contemporaneamente, come gestire input, visualizzare a schermo, monitorare la rete ed eseguire calcoli.\\
Esempi noti: browser web, videogame multiplayer. Si creano \textbf{più componenti interagenti} in modo da:\begin{list}{}{}
	\item Usare meglio le risorse
	\item Migliorare le performance per applicazioni che richiedono grossi calcoli: si dividono i task per eseguirli in parallelo.
	\item Anche problemi: difficile debugging e manutenzione, sincronizzazione, deadlocks\ldots
\end{list}
\paragraph{In Java} Il main thread, invocato dalla JVM all'esecuzione del programma, può attivare altri thread. La JVM attiva automaticamente altri thread come il garbage collector.\\
Un thread è un oggetto. Per creare un thread si definisce un task che implementi l'interfaccia \texttt{Runnable} e si crea un thread passandogli l'istanza del task creato. Altrimenti si può estendere la classe \texttt{java.lang.Thread}.
\paragraph{Runnable} Appartiene a \texttt{java.language}, contiene solo la firma del metodo \texttt{void run()}. Un oggetto che la implementa è un frammento di codice che può essere eseguito in un thread.
\paragraph{Stati}
\begin{list}{}{}
	\item \textbf{Created}/\textbf{New}: subito dopo l'istruzione \texttt{new}, variabili allocate ed inizializzate. Thread in attesa di passare in esecuzione
	\item \textbf{Runnable}/\textbf{Running}: thread in esecuzione o in attesa per ottenere la CPU (Java non separa i due stati).
	\item \textbf{Not Runnable} (\textbf{Blocked}/\textbf{Waiting}): thread non può essere messo in esecuzione, può accadere quando attende un'operazione I/O o ha invocato metodi come \texttt{sleep()} oppure \texttt{wait()}.
	\item \textbf{Dead}: termine naturale o dopo l'invocazione di \texttt{stop()} da parte di altri thread (deprecato).
\end{list}
\subsection{Threadpool}
\paragraph{Perché?} In caso di task leggeri molto frequenti risulta impraticabile attivare ulteriori thread. Diventa quindi utile definire un limite massimo di thread che possono essere attivati contemporaneamente, così da sfruttare meglio i processori, evitare troppi thread in competizione e diminuire i costi di attivazione/terminazione dei thread.
\paragraph{Threadpool} Struttura dati la cui dimensione massima può essere prefissata, contenente riferimenti ad un insieme di thread. I thread possono essere riutilizzati: la sottomissione di un task al threadpool è \textbf{disaccoppiata} dall'esecuzione del thread. L'esecuzione può essere ritardata se non vi sono risorse disponibili.\\
La \textbf{politica di gestione dei thread} stabilisce quando i thread vengono attivati (al momento della creazione del pool, on demand, all'arrivo di un nuovo task\ldots) e quando è opportuno terminare l'esecuzione di un thread.\\
Il threadpool, quindi, al momento della sottomissione di un task può:
\begin{list}{}{}
	\item Usare un thread attivato in precedenza e al momento inattivo
	\item Creare un nuovo thread
	\item Memorizzare il task in una coda, in attesa
	\item Respingere la richiesta
\end{list}
\paragraph{Callable} Classe per definire un task che può restituire un risultato e sollevare eccezioni
\paragraph{Future} Rappresenta il risultato di una computazione asincrona. Definisce metodi per controllare se la computazione è terminata, attendere la terminazione oppure cancellarla. Viene implementata nella classe \texttt{FutureTask}.
\section{Monitor}
\paragraph{Lock Implicite} Ogni oggetto ha associate una lock implicita ed una coda. La lock si acquisisce mediante metodi o blocchi di codice \texttt{synchronized}. Quando questo viene invocato:\begin{list}{}{}
	\item Se nessun metodo \texttt{synchronized} della classe è in esecuzione, l'oggetto viene bloccato (la lock viene acquisita ed il metodo viene eseguito.
	\item Se l'oggetto è già bloccato, il thread viene sospeso nella coda associata finché la lock non viene rilasciata.
\end{list}
Notare che la lock è \textbf{associata all'istanza della classe}, non alla classe. Metodi su istanze (oggetti) diverse della stessa classe possono essere eseguiti concorrentemente.\\
I costruttori non possono essere dichiarati \texttt{synchronized} (errore di compilazione), perché solo il thread che crea l'oggetto deve poterci accedere mentre l'oggetto viene creato.\\
Non ha senso specificare \texttt{synchronized} nelle interfacce poiché è riferito all'implementazione.\\
Inoltre il \texttt{synchronized} non viene ereditato.
\paragraph{Monitor} Meccanismo linguistico ad alto livello per la sincronizzazione. classe di oggetti utilizzabili concorrentemente in modo safe. La risorsa è un oggetto passivo, le sue operazioni vengono invocate da entità attive (thread). La sincronizzazione sullo stato della risorsa è garantita esplicitamente: mutua esclusione sulla struttura garantita dalla lock implicita (un solo thread per volta è all'interno del monitor), meccanismi per sospensione/risveglio sullo stato dell'oggetto condiviso simili a variabili di condizione (\texttt{wait}/\texttt{notify})\\
Il monitor è quindi un \textbf{oggetto} con un insieme di metodi \texttt{synchronized} che incapsula lo stato di una risorsa condivisa. Ha due code gestite implicitamente: entry set (thread in attesa di acquisire la lock) e wait set (thread che hanno eseguito una wait e attendono una notify)
\paragraph{Wait} Sospende il thread in attesa che si verifichi una condizione (opzionalmente per un tempo massimo). Rilascia la lock (a differenza di \texttt{sleep} e \texttt{yield}).
\paragraph{Notify} Sveglia ad un thread in attesa il verificarsi di una certa condizione (\texttt{notifyAll} sveglia tutti i thread in attesa)
\paragraph{Deadlock} Due o più thread bloccati per sempre in attesa uno dell'altro
\paragraph{Starvation} Thread ha difficoltà ad accedere ad una risorsa condivisa e quindi difficoltà a procedere. In generale task "greedy" che invocano spesso metodi lunghi obbligando gli altri ad aspettare
\paragraph{Livelock} Programma che genera una sequenza ciclica di operazioni inutili ai fini dell'effettivo avanzamento della computazione.
\section{Concurrent collections}
\paragraph{Collezioni di oggetti} Insieme di classi che consentono di lavorare con gruppi di oggetti. L'essere o meno thread-safe varia da classe a classe. In generale, tre tipi di collezioni: \textbf{senza supporto} per multithreading, \textbf{synchronized} collections e \textbf{concurrent} collections (introdotte in \texttt{java.util.concurrent}).
\paragraph{Vector} Contenitore elastico (dimensione variabile) e non generico. Thread-safe conservative locking.
\paragraph{ArrayList} Elastico come \texttt{Vector}. Prima di JDK5 poteva contenere solo elementi di tipo \texttt{Object}, adesso è parametrico (generic) rispetto al tipo di oggetti contenuti.\\Elementi possono essere acceduti in modo diretto tramite l'indice. \textbf{Non thread-safe} di default: nessuna sincronizzazione per maggiore efficienza.
\paragraph{Unsynchronized Collections} Come \texttt{ArrayList}, un loro uso incontrollato in un programma multithread può portare a risultati scorretti.
\subsection{Synchronized Collections}
\texttt{Collections} contiene metodi statici per l'elaborazione delle collezioni, \textbf{factory methods} per creare versioni sincronizzate di \texttt{list}/\texttt{set}/\texttt{map}.\begin{list}{}{}
	\item Input: una collezione
	\item Output: la stessa collezione con le operazioni sincronizzate.
\end{list}
La collection risultante è protetta da \textbf{lock sull'intera collezione} $\rightarrow$ degradazione di performance
\paragraph{Nota bene} Nessun thread deve accedere all'oggetto originale, requisito ottenibile con istruzioni del tipo\\\texttt{List<String> synchList = Collections.synchronizedList(new ArrayList<String>());}
\paragraph{Svantaggi} Garantiscono la thread-safety a scapito della scalabilità del programma.
\subsection{Concurrent Collections}
\paragraph{Idea} Accettare un compromesso sulla semantica delle operazioni, così da rendere possibile il mantenimento di un livello di concorrenza tale da garantire una buona scalabilità.\\
Invece di sincronizzare l'intera struttura, si sincronizza solo la parte interessata. Esempio: una hash table ha diversi buckets, quindi sincronizzo solo il bucket a cui accedo.
\paragraph{Concurrent Collections} Implementate in \texttt{java.util.concurrent}, superano l'approccio "\textit{sincronizza l'intera struttura dati}" garantendo quindi un supporto più sofisticato per la sincronizzazione permettendo l'overlapping di operazioni sugli elementi della struttura.
\paragraph{Vantaggio} Maggior livello di concorrenza e quindi migliori performance
\paragraph{Prezzo} Modifica della semantica di alcune operazioni.
\paragraph{Lock Striping} Invece di una sola lock per tutta la struttura, mantengo lock per sezioni. Ad esempio, una hash table suddivisa in sezioni rende possibili write simultanee se modificano sezioni diverse.\\
Posso usare 16 lock per controllare l'accesso alla struttura, un numero arbitrario di lettori ed un numero fisso massimo di scrittori (16) che lavorano simultaneamente. Così lettori e scrittori possono convivere.
\subparagraph{Vantaggi} Maggiore parallelismo e scalabilità
\subparagraph{Svantaggi} Non si può eseguire la lock sull'intera struttura. Si approssima la semantica di alcune operazioni, ad esempio \texttt{size()} e \texttt{isEmpty()}, che restituiscono un valore approssimato.\\
Diventa impossibile sincronizzare funzioni composte da operazioni elementari a livello utente (nelle \texttt{synchronized} si usavano blochi \texttt{synchronized} che lockavano l'intera collezione).\\
Per risolvere questo problema si mettono a disposizione operazioni eseguite atomicamente, come \texttt{putIfAbsent(K key, V val)}, \texttt{removeIfEqual(K key, V val)}, \texttt{replaceIfEqual(K key, V oldVal, V newVal)}
\section{Java NIO}
\paragraph{Obiettivi} Incrementare la performance dell'I/O, fornire un insieme eterogeneo di funzionalità per l'I/O e aumentare l'espressività delle applicazioni.
\paragraph{Non semplice} Per migliorare le performance è necessario definire le primitive a livelli di astrazione più bassi. Inoltre i risultati dipendono dalla piattaforma di esecuzione. Si rende necessario uno sforzo di progettazione maggiore.
\paragraph{Costrutti base}
\subparagraph{Canali e buffer} Invece dell'I/O standard Java che opera su stream di byte o caratteri. I dati sono trasferiti da canali a buffer o viceversa, ed i buffer vengono gestiti esplicitamente dal programmatore.\\
Un \textbf{channel} è simile ad uno stream. I dati possono essere letti dal channel in un buffer e viceversa scritti dal buffer in un channel.
\subparagraph{Buffer} Contenitori di dati di dimensione fissa. Contengono dati appena letti o da scrivere.\\
Sono oggetti della classe \texttt{java.nio.Buffer} \textbf{non thread-safe}.\\
\textbf{Direct Buffers}: buffer allocati fuori dalla JVM, nella memoria gestita dal S.O.
\subparagraph{Selector} Oggetto in grado di monitorare un insieme di canali. Itercetta eventi provenienti dai canali monitorati: dati arrivati, connessione aperta\ldots\\
Sono simili agli stream, ma \textbf{bidirezionali}, con \textbf{scattered read} (distribuisce i dati letti da un canale in uno o più buffer), \textbf{gathering write} (scrive su un canale i dati recuperati da più buffer) e supporta \textbf{trasferimenti diretti tra canali}.
\subparagraph{Channel} Rappresentano connessioni con entità capaci di eseguire operazioni I/O. \texttt{Channel} è un'interfaccia radice di una gerarchia di interfacce:
\begin{list}{}{}
	\item \texttt{FileChannel}: legge/scrive dati su file
	\item \texttt{DatagramChannel}: legge/scrive dati su rete via \texttt{UDP}
	\item \texttt{SocketChannel}: legge/scrive dati su rete via \texttt{TCP}
	\item \texttt{ServerSocketChannel}: attende richieste di connessioni \texttt{TCP} e crea un \texttt{SocketChannel} per ogni connessione creata
\end{list}
Sono \textbf{bidirezionali}. Tutti i dati sono gestiti tramite oggetti di tipo \texttt{Buffer}, quindi senza leggere/scrivere direttamente sul canale. Inoltre possono essere \textbf{bloccanti o meno}, non bloccati utili soprattutto per le comunicazioni in cui i dati arrivano in modo incrementale come i collegamenti di rete.
\section{Serializzazione}
\paragraph{Oggetti} Caratterizzati da stato (vive con l'istanza) e comportamento (specificato dalla classe).
\paragraph{Serialization} Scrittura e lettura di oggetti. Si basa sulla possibilità di scrivere lo stato di un oggetto in una forma sequenziale, sufficiente per ricostrutire l'oggetto quando viene riletto.\\
Il flattening/salvataggio dell'oggetto riguarda lo stato e può avvenire in diversi modi:
\begin{list}{}{}
	\item Accedendo ai singoli campi, salvando i valori per esempio su un file di testo in un formato opportuno
	\item Trasformando automaticamente l'oggetto in uno stream di byte mediante il \textbf{meccanismo della object serialization} di Java
\end{list}
La serializzazione consente di persistere degli oggetti al di fuori del ciclo di vita della JVM. Si crea una rappresentazione dell'oggetto indipendente dalla JVM che ha generato l'oggetto stesso. Un'altra JVM, se ha accesso alla classe ed all'oggetto serializzato, può ricostruirlo.
\paragraph{Persistenza} Fornisce un meccanismo di persistenza dei programmi, consentendo l'archiviazione di un oggetto su un file. Ad esempio, per memorizzare lo stato di una sessione.
\paragraph{Interoperabilità} Meccanismo di interoperabilità mediante oggetti condivisi tra diverse applicazioni.
\paragraph{Approcci}
\subparagraph{Java Object Serialization} Utilizzabile solo se chi serializza e chi deserializza è scritto in Java.
\subparagraph{Testo} Come \texttt{XML} e \texttt{JSON} (JavaScript Object Notation), formati dalla sintassi semplice e facilmente riproducibile. Interpretabile da qualsiasi linguaggio.
\section{JSON}
Formato leggero per interscambio di dati, indipendente dalla piattaforma poiché è semplice testo. Non dipende dal linguaggio di programmazione ed è self-describing.
\paragraph{Strutture} Coppie \texttt{chiave:valore} e liste ordinate di valori. Una risorsa JSON ha una struttura ad albero.
\end{document}